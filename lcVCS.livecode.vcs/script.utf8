

-- bug #8884 : the following are missing from "the properties"
constant kMissingProps = "filename,innershadow,innerglow,outerglow,dropshadow,coloroverlay,fillgradient,strokegradient,resizeQuality,paintCompression"
constant kColorProps = "foregroundColor,backgroundColor,hiliteColor,borderColor,topColor,bottomColor,shadowColor,focusColor"
constant kPatternProps = "foregroundPattern,backgroundPattern,hilitePattern,borderPattern,topPattern,bottomPattern,shadowPattern,focusPattern"
constant kIconProps = "icon,hiliteIcon,disabledIcon,borderPattern,visitedIcon,armedIcon,hoverIcon"
constant kUnicodeProps = "Label,Text,ToolTip,Title"
constant kDeleteProps = "colors,patterns,orientation,scroll,framecount,visited"
constant kTempNameSuffix = " temp"
constant kTemplateObjects = "the templateStack,the templateGroup,the templateCard,the templateGraphic,the templateButton,the templateField,the templateScrollbar,the templateImage,the templatePlayer"
constant kExtension = "vcs"

local sIDMap,sUUIDsToResolve,sTemplateObjects,sLayersToSet,sConflicts,sUUIDCache

command ExportStackFile pFilePath
   local tFolder,tStacks,tSubstacks,tIndex,tJSON
   lock screen
   if there is a stack pFilePath then
      resetTemplateObjects
      -- mainstack
      lock messages
      put pFilePath into tFolder
      put "."&kExtension after tFolder
      if there is not a folder tFolder then
         create folder tFolder
      end if
      set the defaultFolder to tFolder
      get ExportStack(the mainstack of stack pFilePath,true)
      -- substacks
      if the substacks of stack pFilePath is not empty then
         set the defaultFolder to tFolder
         if there is not a folder "substacks" then
            create folder "substacks"
         end if
         set the defaultFolder to "substacks"
         repeat for each line tStack in the substacks of stack pFilePath
            put tStack into tObjects[ExportStack(tStack)]
         end repeat
         deleteObjectsFromFolder tObjects
      end if
   end if
   save stack pFilePath
   revertTemplateObjects
end ExportStackFile

on ImportStackFile pFolder
   local tUUIDSearchDone = "false"
   lock screen
   lock messages
   delete variable sUUIDsToResolve
   delete variable sLayersToSet
   resetTemplateObjects
   set the defaultFolder to pFolder
   ImportObject
   put  the short name of sIDMap[the result] into tMainstack
   -- only load uuids from all mainstacks if necessary
   repeat for each key tObject in sUUIDsToResolve
      repeat for each key tProperty in sUUIDsToResolve[tObject]
         -- resolve uuid references (icons, patterns, behaviors)
         -- load uuids from all mainstacks only if required
         if there is not a sIDMap[sUUIDsToResolve[tObject][tProperty]] and not tUUIDSearchDone then
            put true into tUUIDSearchDone
            repeat for each line tMainstack in the mainstacks
               repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
                  repeat with tCard = 1 to the number of cards of stack tStack
                     -- behavior buttons
                     repeat with tControl =1 to the number of buttons of card tCard of stack tStack
                        if the uVersion["uuid"] of btn tControl of card tCard of stack tStack <> "" then
                           put the long id of btn tControl of card tCard of stack tStack into sIDMap[uuidForObject(the long id of btn tControl of card tCard of stack tStack)]
                        end if
                     end repeat
                     -- images
                     repeat with tControl =1 to the number of images of card tCard of stack tStack
                        if the uVersion["uuid"] of image tControl of card tCard of stack tStack <> "" then
                           put the long id of image tControl of card tCard of stack tStack into sIDMap[uuidForObject(the long id of image tControl of card tCard of stack tStack)]
                        end if
                     end repeat
                  end repeat
               end repeat
            end repeat
         end if
         if there is a sIDMap[sUUIDsToResolve[tObject][tProperty]] then
            switch tProperty
               case "behavior"
                  set the tProperty of tObject to sIDMap[sUUIDsToResolve[tObject][tProperty]]
                  break
               case "defaultButton"
                  set the default of sIDMap[sUUIDsToResolve[tObject][tProperty]] to true
                  break
               case "row template"
                  set the dgProps["row template"] of tObject to word 1 to -4 of the long id of sIDMap[sUUIDsToResolve[tObject][tProperty]]
                  break
               default
                  set the tProperty of tObject to the short id of sIDMap[sUUIDsToResolve[tObject][tProperty]]
                  break
            end switch
         else
            try -- could be some object that wasn't in memory during the export so it's not a uuid
               set the tProperty of tObject to sUUIDsToResolve[tObject][tProperty]
            end try
         end if
      end repeat
   end repeat
   SetLayers
   set the itemDel to "."
   if item -1 of pFolder = "vcs" then
      delete item -1 of pFolder
   end if
   set the fileName of stack tMainStack to pFolder
   go cd 1 of stack tMainStack
   if tMainStack = ("lcVCS"&kTempNameSuffix) then
      send "PostImportStack" to stack tMainStack in 0 milliseconds
   end if
   revertTemplateObjects
   if sConflicts is an array then
      modeless "lcVCSConflicts"
   end if
end ImportStackFile

command SetLayers
   local tLayers,tCardUUID,tObject,tCards
   -- interleave conflicted card layers
   repeat for each key tStackUUID in sLayersToSet["cardlayers"]
      repeat for each key tCardUUID in sLayersToSet["cardlayers"][tStackUUID]
         put tCardUUID,sLayersToSet["cardlayers"][tStackUUID][tCardUUID] &cr after tCards
      end repeat
      sort tCards numeric by item 2 of each
      repeat for each line tCard in tCards
         put item 1 of tCard into tCardUUID
         if tCardUUID = "" then next repeat
         go sIDMap[tCardUUID]
         put the keys of sLayersToSet["objectlayers"][tCardUUID] into tLayers
         sort tLayers numeric
         repeat for each line tLayer in tLayers
            try
               -- interleave conflicted layers
               repeat for each line tObject in sLayersToSet["objectlayers"][tCardUUID][tLayer]
                  relayer tObject to front of owner
               end repeat
            end try
         end repeat
         set the layer of sIDMap[tCardUUID] to sLayersToSet["cardlayers"][tStackUUID][tCardUUID]
      end repeat
      close sIDMap[tStackUUID]
      delete variable tCards
   end repeat
end SetLayers

-- if the stack gets this message then it just 
-- imported a version of itself with a temp name
on PostImportStack
   -- delete stacks (remove stackfile from memory)
   put the short name of this stack into tStack
   put tStack into tStackName
   replace kTempNameSuffix with empty in tStackName
   if there is a stack tStackName then
      delete stack tStackName
   end if
   -- set names correctly
   set the name of stack tStack to tStackName
   put the substacks of stack tStackName into tSubstacks
   repeat for each line tStack in tSubstacks
      put tStack into tStackName
      replace kTempNameSuffix with empty in tStackName
      if there is a stack tStackName then
         delete stack tStackName
      end if
      set the name of stack tStack to tStackName
   end repeat
end PostImportStack

on ImportObject pStackUUID,pCardUUID,pParentUUID
   local tObject,tSetName,tType,tError,tConflict=false
   put url ("binfile:properties.json") into tObject
   try
      put JSONToArray(tObject) into tObject["A"]
   catch tError
      -- most likely there's conflict markers causing an issue or someone's bad manual edit...
      put ParseConflictedFile(tObject) into tObject
      try
         put JSONToArray(tObject["A"]) into tObject["A"]
         put JSONToArray(tObject["B"]) into tObject["B"]
         -- make sure it's a real difference in an element value not 
         -- just the two branches adding to the last item of the same JSON object (trailing comma issue)
         -- union will add elements from one object to another but won't mess with existing elements
         union tObject["A"] with tObject["B"]
         union tObject["B"] with tObject["A"]
         -- if the arrays are now the same then we know it was just a trailing comma issue
         if tObject["A"] is tObject["B"] then
            delete variable tObject["B"]
         end if
      catch tError
         answer "There was an error decoding properties file:"&cr&the defaultFolder&"/properties.json"&cr&tError
         exit to top
      end try
   end try
   put uniDecode(uniEncode(tObject["A"]["properties"]["name"],"UTF8"),"ANSI") into tObject["A"]["properties"]["name"]
   switch tObject["A"]["class"]
      case "com.runrev.engine.stack"
         -- support VCS on self
         if tObject["A"]["properties"]["name"] = "lcVCS" or \
               (pStackUUID is not empty and the short name of sIDMap[pStackUUID] = ("lcVCS"&kTempNameSuffix))  then
            create stack (tObject["A"]["properties"]["name"]&kTempNameSuffix)
         else
            if there is a stack tObject["A"]["properties"]["name"] then
               delete stack tObject["A"]["properties"]["name"]
            end if
            create stack tObject["A"]["properties"]["name"]
         end if
         set the defaultStack to it
         set the loc of it to the screenLoc
         -- workaround for the fact that the first card is already created
         -- and we use this for a background creation card
         -- a new stack id is always 1002 so the id of 1000 will be safe
         set the id of card 1 of it to 1000
         if pStackUUID is not empty then
            set the mainstack of it to the short name of sIDMap[pStackUUID]
         end if
         put tObject["A"]["uuid"] into pStackUUID
         break
      case "com.runrev.engine.card"
         create card tObject["A"]["properties"]["name"]
         put tObject["A"]["uuid"] into pCardUUID
         break
      case "com.runrev.engine.image"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create image tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create image tObject["A"]["properties"]["name"]
         end if
         if there is a file ("image."&tObject["A"]["properties"]["paintCompression"]) then
            set the text of it to url ("binfile:image."&tObject["A"]["properties"]["paintCompression"])
         end if
         delete variable tObject["A"]["properties"]["paintCompression"]
         break
      case "com.runrev.engine.button"
         ##! workaround bug http://quality.runrev.com/show_bug.cgi?id=10696
         set the style of the templateButton to tObject["A"]["properties"]["style"]
         delete variable tObject["A"]["properties"]["style"]
         if word 1 of sIDMap[pParentUUID] is "group" then
            create button tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create button tObject["A"]["properties"]["name"]
         end if
         reset the templateButton
         break
      case "com.runrev.engine.field"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create field tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create field tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.player"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create player tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create player tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.scrollbar"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create scrollbar tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create scrollbar tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.graphic"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create graphic tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create graphic tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.group"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create group tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create group tObject["A"]["properties"]["name"]
         end if
         break
      default
         ##! TODO
         -- custom control so find appropriate template object
         -- copy it to the appropriate spot
         
         break
   end switch
   if tObject["A"]["class"] <> "com.runrev.engine.stack" then
      put the abbrev id of it &" of "& sIDMap[pStackUUID] into sIDMap[tObject["A"]["uuid"]]
   else
      put it into sIDMap[tObject["A"]["uuid"]]
   end if
   set the itemDel to ","
   -- workaround for rect messing up gradients issue
   if tObject["A"]["class"] is "com.runrev.engine.graphic" and tObject["A"]["properties"]["rect"] is not empty then
      set the rect of sIDMap[tObject["A"]["uuid"]] to tObject["A"]["properties"]["rect"]
   end if
   delete variable tObject["A"]["properties"]["name"]
   SetObjectProperties tObject["A"],pCardUUID
   put uniDecode(uniEncode(url ("binfile:script.utf8"),"UTF8"),"ANSI") into tScript
   set the script of sIDMap[tObject["A"]["uuid"]] to tScript
   -- conflict resolution
   if the result contains ">>>>>>>" then
      -- script compilation error caused by conflict markers
      AddToConflicts sIDMap[tObject["A"]["uuid"]],"script"
      put true into tConflict
   end if
   if tObject["B"] is an array then
      AddToConflicts sIDMap[tObject["A"]["uuid"]],"properties",tObject
      put true into tConflict
   end if
   if not tConflict then
      resolveConflict sIDMap[tObject["A"]["uuid"]]
   end if
   put tObject["A"]["uuid"] into tVersion["UUID"]
   put the short id of sIDMap[tObject["A"]["uuid"]] into tVersion["ID"]
   set the customProperties["uVersion"] of sIDMap[tObject["A"]["uuid"]] to tVersion
   if tObject["A"]["class"] <> "com.runrev.engine.stack" then
      repeat for each line tUUID in the folders
         if char 1 of tUUID = "." then next repeat
         set the defaultFolder to tUUID
         ImportObject pStackUUID,pCardUUID,tObject["A"]["uuid"]
         set the defaultFolder to ".."
      end repeat
   else
      repeat for each item tType in "cards,sharedGroups,substacks"
         if there is a folder tType then
            set the defaultFolder to tType
            repeat for each line tUUID in the folders
               if tType = "sharedGroups" then
                  go ("cd 1 of "&sIDMap[pStackUUID])
               end if
               if char 1 of tUUID = "." then next repeat
               set the defaultFolder to tUUID
               if tType = "substacks" then
                  ImportObject pStackUUID
               else
                  ImportObject pStackUUID,pCardUUID
               end if
               set the defaultFolder to ".."
            end repeat
            set the defaultFolder to ".."
         end if
         switch tType
            case "cards"
               -- find card layer 1 and put it's uuid into 
               repeat with X=1 to the number of cards of sIDMap[pStackUUID]
                  put uuidForObject(the long id of card X of sIDMap[pStackUUID]) into pCardUUID
                  if sLayersToSet["cardlayers"][pCardUUID] is 1 then exit repeat
               end repeat
               break
            case "sharedGroups"
               delete card 1
               close this stack
               break
         end switch
      end repeat
   end if
   return pStackUUID
end ImportObject

command SetObjectProperties pProperties,pCardUUID
   local tOwner
   -- workaround for rect messing up gradients issue
   if pProperties["class"] is "com.runrev.engine.graphic" and pProperties["properties"]["rect"] is not empty then
      set the rect of sIDMap[pProperties["uuid"]] to pProperties["properties"]["rect"]
   end if
   delete variable pProperties["properties"]["name"]
   repeat for each key tProperty in pProperties["properties"]
      switch
         case tProperty is "id"
            try
               set the id of sIDMap[pProperties["uuid"]] to pProperties["properties"][tProperty]
               put pProperties["properties"][tProperty] into word 3 of sIDMap[pProperties["uuid"]]
            end try
            break
         case tProperty is "layer"
            if pProperties["class"] is "com.runrev.engine.card" then
               put pProperties["properties"][tProperty] into sLayersToSet["cardlayers"][uuidForObject(the owner of sIDMap[pProperties["uuid"]])][pProperties["uuid"]]
            else
               if pProperties["properties"][tProperty] is an array then
                  put "" into tFirstCard["layer"]
                  -- it's a background that needs to be placed
                  repeat for each key tCardUUID in pProperties["properties"][tProperty]
                     put the abbrev id of sIDMap[pProperties["uuid"]]&" of "&sIDMap[tCardUUID] &cr after sLayersToSet["objectlayers"][tCardUUID][pProperties["properties"][tProperty][tCardUUID]]
                     try -- throws error if it's already on the card
                        place sIDMap[pProperties["uuid"]] onto sIDMap[tCardUUID]
                     end try
                  end repeat
               else
                  -- support calling this command independent of main import for conflict resolution
                  if pCardUUID is empty then
                     put the long owner of sIDMap[pProperties["uuid"]] into tOwner
                     repeat forever
                        if word 1 of tOwner is "card" then
                           put uuidForObject(tOwner) into pCardUUID
                           exit repeat
                        end if
                        put the long owner of tOwner into tOwner
                     end repeat
                  end if
                  put sIDMap[pProperties["uuid"]] into sLayersToSet["objectlayers"][pCardUUID][pProperties["properties"][tProperty]]
               end if
            end if
            break
         case tProperty is among the items of kIconProps,kPatternProps
         case tProperty is "behavior"
         case tProperty is "defaultButton"
            -- store the value 
            if pProperties["properties"][tProperty] <> "" then
               put pProperties["properties"][tProperty] into sUUIDsToResolve[sIDMap[pProperties["uuid"]]][tProperty]
            end if
            break
         case char 8 to -1 of tProperty is among the items of kUnicodeProps -- "unicode"&tProperty
            -- utf8 encoded
            set the tProperty of sIDMap[pProperties["uuid"]] to uniEncode(pProperties["properties"][tProperty],"UTF8")
            break
         case tProperty is among the items of "htmlText,hilite"
            if pProperties["properties"][tProperty] is an array then
               put the short id of sIDMap[pProperties["uuid"]] into tID
               repeat for each key tUUID in pProperties["properties"][tProperty]
                  put "control id "&tID&" of "&sIDMap[tUUID] into tControl
                  set the tProperty of tControl to pProperties["properties"][tProperty][tUUID]
               end repeat
               break
            end if
         default
            try
               set the tProperty of sIDMap[pProperties["uuid"]] to pProperties["properties"][tProperty]
            end try
            break
      end switch
   end repeat
   repeat for each key tCustomPropertySet in pProperties["customPropertySets"]
      if tCustomPropertySet = "dgProps" then
         put pProperties["customPropertySets"][tCustomPropertySet]["row template"] into sUUIDsToResolve[sIDMap[pProperties["uuid"]]]["row template"]
      end if
      if tCustomPropertySet is "customKeys" then
         set the customProperties[""] of sIDMap[pProperties["uuid"]] to pProperties["customPropertySets"][tCustomPropertySet]
      else
         set the customProperties[uniDecode(uniEncode(tCustomPropertySet,"UTF8"),"ANSI")] of sIDMap[pProperties["uuid"]] to pProperties["customPropertySets"][tCustomPropertySet]
      end if
   end repeat
end SetObjectProperties

command AddToConflicts pObject,pType,pProperties
   put true into sConflicts[pObject][pType] 
   if pType = "properties" then
      put pProperties into sConflicts[pObject]["propertiesdata"]
   end if
end AddToConflicts

function getConflicts
   return sConflicts
end getConflicts

command resolveConflict pObject
   delete variable sConflicts[pObject]
end resolveConflict

command ArrayDiff @pArray1,@pArray2
   local tKeys1,tKeys2
   -- use the list of keys so we make sure we support empty elements
   put the keys of pArray1 into tKeys1
   put the keys of pArray2 into tKeys2
   -- any keys in pArray1 that aren't in pArray2 should stay
   repeat for each line tKey in tKeys2
      -- any keys in pArray2 that aren't in pArray1 should stay
      if tKey is among the lines of tKeys1 then
         if pArray2[tKey] = pArray1[tKey] then
            delete variable pArray2[tKey]
            delete variable pArray1[tKey]
         end if
         -- if they are different and only one is an array then keep both
         if pArray1[tKey] is an array and pArray2[tKey] is an array then
            ArrayDiff pArray1[tKey],pArray2[tKey]
         end if
      end if
   end repeat
end ArrayDiff

private function uuidForObject pObject
   if not exists(pObject) then return empty
   put word -2 to -1 of pObject into tStack
   put the customProperties["uVersion"] of pObject into tVersion
   if tVersion["UUID"] = ""  or \
         (the short id of pObject <> tVersion["ID"] and \
         there is a control id tVersion["ID"] of tStack and \
         tVersion["UUID"] = the uVersion["UUID"] of control id tVersion["ID"] of tStack) then
      _internal call "generate_uuid"
      put the result into tVersion["UUID"]
      put the short id of pObject into tVersion["ID"]
      set the customProperties["uVersion"] of pObject to tVersion
   end if
   return tVersion["UUID"]
end uuidForObject

function ExportStack pStack,tMainstack
   local tIndex,tIsOpen
   put pStack is among the lines of the openstacks into tIsOpen
   if not tIsOpen then
      go stack pStack
   end if
   set the defaultStack to pStack
   put uuidForObject(the long id of stack pStack) into tUUID
   get ExportObject(the long id of stack pStack,,tMainstack)
   if not tIsOpen then
      close stack pStack
   end if
   return tUUID
end ExportStack

function ExportObjectProperties pObject,pShared,pMainstack
   local tImage,tObject,tGroupCardRef
   unlock messages
   dispatch "lcVCSExport" to pObject
   lock messages
   put uuidForObject(pObject) into tObject["uuid"]
   if not pMainstack then
      if there is not a folder tObject["uuid"] then
         create folder tObject["uuid"]
      end if
      set the defaultFolder to tObject["uuid"]
   end if
   put pObject into sIDMap[tObject["uuid"]]
   -- properties
   put the properties of pObject into tObject["properties"]
   -- we don't want object names that are really abbrev ids because the id might change
   if the short name of pObject <> the abbrev id of pObject then
      put uniDecode(uniEncode(tObject["properties"]["name"],"ANSI"),"UTF8") into tObject["properties"]["name"]
   else
      delete variable tObject["properties"]["name"]
   end if
   -- colors and patterns better as individual props
   repeat for each item tProperty in kDeleteProps
      delete variable tObject["properties"][tProperty]
   end repeat
   if tObject["properties"]["behavior"] is not empty then
      put uuidForObject(tObject["properties"]["behavior"]) into tObject["properties"]["behavior"]
   end if
   if the cIDEProperties["cCustomControlID"] of pObject <> "" then
      put the cIDEProperties["cCustomControlID"] of pObject into tObjectClass
   else
      if word 1 of pObject is "bkgnd" then
         put "com.runrev.engine.group" into tObjectClass
      else
         put "com.runrev.engine."&word 1 of pObject into tObjectClass
      end if
   end if
   put tObjectClass into tObject["class"]
   try
      put the script of pObject into tScript
      if tScript <> "" then
         put uniDecode(uniEncode(tScript,"ANSI"),"UTF8") into tScript
      end if
   catch e
      put "-- password protected scripts unspported" into tScript
   end try
   repeat for each item tProperty in kUnicodeProps
      if tObject["properties"][tProperty] <> "" then
         try
            put "unicode"&tProperty into tUnicodeProperty
            put uniDecode(the tUnicodeProperty of pObject,"UTF8") into tObject["properties"][tUnicodeProperty]
            delete variable tObject["properties"][tProperty]
         end try
      end if
   end repeat
   repeat for each item tProperty in kMissingProps
      try
         put the tProperty of pObject into tObject["properties"][tProperty]
      end try
   end repeat
   if word 1 of pObject is not "image" then
      repeat for each item tProperty in kColorProps
         try
            put the tProperty of pObject into tObject["properties"][tProperty]
         end try
      end repeat
      repeat for each item tProperty in kPatternProps
         try
            put the tProperty of pObject into tID
            if tID <> "" and tID <> 0 then
               put iconImage(tID,pObject) into tObject["properties"][tProperty]
               if there is a tObject["properties"][tProperty] then
                  put uuidForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
               end if
            end if
         end try
      end repeat
   end if
   switch word 1 of pObject
      case "stack"
         -- should be saved next to the folder
         delete variable tObject["properties"]["filename"]
         -- only want conflict on width and height difference not stack location
         delete variable tObject["properties"]["rect"]
         put the width of pObject into tObject["properties"]["width"]
         put the height of pObject into tObject["properties"]["height"]
         -- stack id is too likely to cause a conflict and will resolve itself anyway
         delete variable tObject["properties"]["id"]
         break
      case "image"
         put the text of pObject into url ("binfile:image."&tObject["properties"]["paintCompression"])
         delete variable tObject["properties"]["size"}
         break
      case "card"
         delete variable tObject["properties"]["rect"]
         if tObject["properties"]["defaultButton"] <> "" then
            put uuidForObject(tObject["properties"]["defaultButton"]) into tObject["properties"]["defaultButton"]
         end if
         break
      case "group"
      case "bkgnd"
         -- no point exporting group rect if it's not locked
         if not the lockLoc of pObject then
            delete variable tObject["properties"]["rect"]
         end if
         put the sharedBehavior of pObject into tObject["properties"]["sharedBehavior"]
         put the selectGroupedControls of pObject into tObject["properties"]["selectGroupedControls"]
         if tObject["properties"]["sharedBehavior"] then
            -- get a layer for each card because they can ne different
            repeat for each line tCardName in the cardNames of pObject
               try
                  put the long id of card tCardName into tID
               catch e
                  put the long id of tCardName into tID
               end try
               put the abbrev name of pObject&" of "&tID into tGroupCardRef
               put the layer of tGroupCardRef into tObject["properties"]["layer"][uuidForObject(tID)]
            end repeat 
         end if
         break
      case "button"
         if not the sharedHilite of pObject and pShared then
            put word 3 of pObject into tID
            repeat for each line tCardID in the cardIDs of the defaultStack
               if there is a button id tID of card id tCardID of the defaultStack then
                  put uuidForObject(the long id of card id tCardID of the defaultStack) into tUUID
                  put the hilite of button id tID of card id tCardID of the defaultStack into tObject["properties"]["hilite"][tUUID]
               end if
            end repeat 
         end if 
         repeat for each item tProperty in kIconProps
            try
               if tObject["properties"][tProperty] <> "" and tObject["properties"][tProperty] <> 0 then
                  put iconImage(tObject["properties"][tProperty],pObject) into tObject["properties"][tProperty]
                  if tObject["properties"][tProperty] is not an integer then
                     put uuidForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
                  end if
               end if
            end try
         end repeat
         break
      case "field"
         if not the sharedText of pObject and pShared then
            put word 3 of pObject into tID
            repeat for each line tCardID in the cardIDs of the defaultStack
               if there is a field id tID of card id tCardID of the defaultStack then
                  put uuidForObject(the long id of card id tCardID of the defaultStack) into tUUID
                  put the htmlText of field id tID of card id tCardID of the defaultStack into tObject["properties"]["htmlText"][tUUID]
               end if
            end repeat 
         end if
         break
   end switch
   if there is a stack tObjectClass then
      put the cControlData of stack tObjectClass into tControlData
      put tControlData["template_group"] into tTemplateObject
   else
      if word 1 of pObject is "bkgnd" then
         put "the templateGroup" into tTemplateObject
      else
         put "the template"&word 1 of pObject into tTemplateObject
      end if
   end if
   repeat for each key tProperty in tObject["properties"]
      if tProperty is not "layer" then
         if tObject["properties"][tProperty] is the tProperty of tTemplateObject then
            -- double check that we are not comparing an array to a simple var
            if (tObject["properties"][tProperty] is an array and the tProperty of tTemplateObject is an array) or \
                  (tObject["properties"][tProperty] is not an array and the tProperty of tTemplateObject is not an array) then
               delete variable tObject["properties"][tProperty]
            end if
         end if
      end if
   end repeat
   -- custom properties
   if the customKeys of pObject is not empty or the customPropertySets of pObject is not empty then
      put 1 into tIndex
      repeat for each line tCustomPropertySet in ""&cr&the customPropertySets of pObject
         put the customProperties[tCustomPropertySet] of pObject into tPropertySetA
         put the customProperties[tCustomPropertySet] of tTemplateObject into tTemplatePropertySetA
         if tCustomPropertySet = "" then put "customKeys" into tCustomPropertySet
         switch tCustomPropertySet
            case "uVersion"
               -- redundant as reset during import
               break
            case "cREVGeometryCache"
            case "cREVGeometryCacheIDs"
               -- revGeometry will regenerate it's cache as needed
               break
            case "cREVGeneral"
               -- delete some unnecessaries
               delete variable tPropertySetA["breakpointconditions"]
               delete variable tPropertySetA["breakpointstates"]
               delete variable tPropertySetA["breakpoints"]
               delete variable tPropertySetA["scripteditorselection"]
               delete variable tPropertySetA["scripteditorvscroll"]
               delete variable tPropertySetA["bookmarks"]
               delete variable tPropertySetA["handlerList"]
               delete variable tPropertySetA["scriptSelection"]
               delete variable tPropertySetA["prevHanlder"]
               delete variable tPropertySetA["tempScript"]
               delete variable tPropertySetA["script"]
               delete variable tPropertySetA["scriptCheckSum"]
               delete variable tPropertySetA["stackfileversion"]
            case "dgProps"
               -- handle row template but need better way for custom control authors to deal with this
               if tPropertySetA["row template"] <> "" then
                  put uuidForObject(tPropertySetA["row template"]) into tPropertySetA["row template"]
               end if
            default
               if keys(tPropertySetA) is not empty then
                  if tTemplatePropertySetA is an array then
                     repeat for each key tProperty in tPropertySetA
                        if tPropertySetA[tProperty] = tTemplatePropertySetA[tProperty] then
                           delete variable tPropertySetA[tProperty]
                        end if
                     end repeat
                  end if
                  if the number of elements in tPropertySetA > 0 then
                     put tPropertySetA into tObject["customPropertySets"][uniDecode(uniEncode(tCustomPropertySet,"ANSI"),"UTF8")]
                  end if
                  add 1 to tIndex
               end if
               break
         end switch
      end repeat
   end if
   if the number of elements of tObject["customPropertySets"] is 0 then
      delete variable tObject["customPropertySets"]
   end if
   if the number of elements of tObject["properties"] is 0 then
      delete variable tObject["properties"]
   end if
   put ArrayToJSON(tObject,,true) into tJSON
   put tJSON into url ("binfile:properties.json")
   if tScript is not empty then 
      put tScript into url ("binfile:script.utf8")
   else
      if there is a file "script.utf8" then
         delete file "script.utf8"
      end if
   end if
   return tObject["uuid"]
end ExportObjectProperties

function ExportObject pObject,pShared,pMainstack
   local tObjects
   -- properties of stack
   put ExportObjectProperties(pObject,pShared,pMainstack) into tUUID
   -- child objects
   put 1 into tIndex
   put the defaultFolder into tFolder
   switch word 1 of pObject
      case "stack"
         -- cards
         if there is not a folder "cards" then
            create folder "cards"
         end if
         set the defaultFolder to "cards"
         repeat for each line tID in the cardIDs of pObject
            put the long id of card id tID of pObject into tObjects[ExportObject(the long id of card id tID of pObject,,false)]
         end repeat
         deleteObjectsFromFolder tObjects
         delete variable tObjects
         -- shared groups
         if the sharedGroupIDs of pObject is not empty then
            set the defaultFolder to tFolder
            if there is not a folder "sharedGroups" then
               create folder "sharedGroups"
            end if
            set the defaultFolder to "sharedGroups"
            repeat for each line tID in the sharedGroupIDs of pObject
               put the long id of background id tID of pObject into tObjects[ExportObject(the long id of background id tID of pObject,true,false)]
            end repeat
            deleteObjectsFromFolder tObjects
            delete variable tObjects
         end if
         set the defaultFolder to tFolder
         break
      case "card"
      case "group"
      case "bkgnd"
         -- only if it's not a cusom control
         if the cIDEProperties["cCustomControlID"] of pObject = "" then
            repeat with tControl=1 to the number of controls of pObject
               put the long id of control tControl of pObject into tControlID
               if the long id of the owner of tControlID is pObject and \
                     not (word 1 of tControlID is "group" and \
                     the sharedBehavior of tControlID) then
                  put tControlID into tObjects[ExportObject(tControlID,pShared,false)]
               end if
            end repeat
         end if
         deleteObjectsFromFolder tObjects
         delete variable tObjects
         break
   end switch
   if not pMainstack then
      set the defaultFolder to ".."
   end if
   return tUUID
end ExportObject

on deleteObjectsFromFolder tObjects
   -- delete folders from deleted stacks
   repeat for each line tFolder in the folders
      if tFolder is not ".." and tObjects[tFolder] = "" then
         revDeleteFolder tFolder
      end if
   end repeat
end deleteObjectsFromFolder

function q pParam
   return quote&pParam&quote
end q

function needsEncoding pData
   if pData contains null then return true
   repeat for each byte tByte in pData
      put charToNum(tByte) into tNum
      if tNum < 9 or (tNum > 13 and tNum < 32) or tNum = 11 or tNum = 12 or tNum > 126 then
         return true
      end if
   end repeat
   return false
end needsEncoding

function iconImage pID,pObject
   --1) The stack of the object's behavior (if applicable)
   --2) The stack of the owner of the object's behavior (if applicable)
   -- ...
   --n) The stack of the object's stack's behavior (if applicable)
   put checkBehaviors(pID,pObject) into tImage
   if tImage is not empty then
      return tImage
   end if
   --A) The object's stack
   if word -5 of pObject = "stack" then 
      -- substack
      put word -5 to -4 of pObject into tStack
   else
      put word -2 to -1 of pObject into tStack
   end if
   if there is an image id pID of tStack then
      return the long id of image id pID of tStack
   end if
   --B) The object's stack's mainstack (if a substack)
   if the short name of tStack is not the mainstack of tStack then
      if there is an image id pID of stack the mainstack of tStack then
         return the long id of image id pID of stack the mainstack of tStack
      end if
   end if
   --C) The object's stack's mainstacks substacks
   repeat for each line tSubstack in the substacks of stack the mainstack of tStack
      if there is an image id pID of stack tSubstack then
         return the long id of image id pID of stack tSubstack
      end if
   end repeat
   --D) The list of open stacks, in order they were loaded
   repeat for each line tMainstack in the mainstacks
      repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
         if there is an image id pID of stack tStack then
            return the long id of image id pID of stack tStack
         end if
      end repeat
   end repeat
   return pID
end iconImage

function checkBehaviors pID,pObject
   put word -2 to -1 of the behavior of pObject into tStack
   if the behavior of pObject <> ""  and \
         there is an image id pID of tStack then
      return the long id of image id pID of tStack
   else
      if word 1 of pObject = "stack" then
         return ""
      else
         return checkBehaviors(pID,the long id of the owner of pObject)
      end if
   end if
end checkBehaviors

command resetTemplateObjects
   -- reset template objects
   repeat for each item tObject in kTemplateObjects
      put the properties of tObject into sTemplateObjects[tObject]
   end repeat
   -- reset command doesn't compile with a variable
   reset the templateStack
   reset the templateGroup
   reset the templateCard
   reset the templateGraphic
   reset the templateButton
   reset the templateScrollbar
   reset the templateImage
   reset the templatePlayer
   reset the templateField
end resetTemplateObjects

command revertTemplateObjects
   -- reset template objects to saved props
   repeat for each item tObject in kTemplateObjects
      set the properties of tObject to sTemplateObjects[tObject]
   end repeat
end revertTemplateObjects

function ParseConflictedFile tFile
   local tState,tReturn
   -- extract both versions of the file
   -- assumes someone hasn't done something crazy like change the conflicted marker length!!!
   repeat for each line tLine in tFile
      switch char 1 to 7 of tLine
         case "<<<<<<<" -- A starts on next line
            put "A" into tState
            break
         case "|||||||" -- Original starts on next line
            put "O" into tState
         case "=======" -- B starts on next line
            put "B" into tState
            break
         case ">>>>>>>" -- conflict ends
            put "" into tState
            break
         default
            if tState is "" then
               put tLine&cr after tReturn["A"]
               put tLine&cr after tReturn["B"]
            else
               if tState is not "O" then
                  put tLine&cr after tReturn[tState]
               end if
            end if
            break
      end switch
   end repeat
   return tReturn
end ParseConflictedFile

function sharedObject pObject
   repeat while there is a pObject
      if word 1 of the owner of pObject is "card" then
         if word 1 of pObject is "group" and the sharedBehavior of pObject then
            return true
         else
            return false
         end if
      end if
      put the owner of pObject into pObject
   end repeat
end sharedObject

function pathForObject pObject
   local tPath
   put "/" into tPath
   repeat forever
      put "/"&uuidForObject(pObject) before tPath
      switch
         case word 1 of pObject is "card"
            put "/cards" before tPath
            break
         case (word 1 of pObject is "group" and the sharedBehavior of pObject) or word 1 of pObject = "bkgnd"
            put "/sharedGroups" before tPath
            break
         case word 1 of pObject is "stack" and the number of words of pObject is 5 
            put "/substacks" before tPath
            break
      end switch
      put the long owner of pObject into pObject
      if the number of words of pObject is 2 then
         exit repeat
      end if
   end repeat
   return the effective filename of pObject&"."&kExtension&tPath 
end pathForObject

-- pArray - array to be encoded
-- pForceRootType - can force the root to be an object if it looks like an array
-- pPretty - include whitespace
function ArrayToJSON pArray,pForceRootType,pPretty
   local tArray,tKeys
   repeat for each line tKey in the keys of pArray
      if pArray[tKey] is an array then
         put "}"&ArrayToJSON(pArray[tKey],pForceRootType) into tArray[tKey]
      else if needsEncoding(pArray[tKey]) then
         put "base64Decode("&base64Encode(pArray[tKey])&")" into tArray[tKey]
      else 
         -- force all elements to be strings
         put "}}"&pArray[tKey] into tArray[tKey]
      end if
   end repeat
   return mergJSONEncode("tArray",pForceRootType,pPretty)
end ArrayToJSON

function JSONToArray pJSON
   local tArray,tKeys
   if pJSON = "" then return ""
   put mergJSONDecode(pJSON,"tArray") into tKeys
   repeat for each line tKey in the keys of tArray
      if tKey is among the lines of tKeys then
         put JSONToArray(tArray[tKey]) into tArray[tKey]
      else
         if char 1 to 13 of tArray[tKey] is "base64Decode(" then
            put base64Decode(char 14 to -2 of tArray[tKey]) into tArray[tKey]
         end if
      end if
   end repeat
   return tArray
end JSONToArray
