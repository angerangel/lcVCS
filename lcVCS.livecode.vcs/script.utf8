
constant kUnicodeProps = "unicodeTitle,unicodeLabel,unicodeToolTip,unicodeText"
constant kIconProps = "icon,hiliteIcon,disabledIcon,visitedIcon,armedIcon,hoverIcon"
constant kPatternProps = "forePattern,focusPattern,backPattern,borderPattern,bottomPattern,hilitePattern,shadowPattern,topPattern"
constant kTempNameSuffix = " temp"
constant kExtension = "vcs"

local sIDMap,sUUIDsToResolve,sTemplateObjects,sLayersToSet,sConflicts,sUUIDCache,sStacksToReopen
local sPlugins -- an array with loaded plugins for UUID resolution and unnecessary custom property filtering

command ExportProject pFilePath
   put ResolveProjectFile(pFilePath) into tProject
   set the itemDel to slash
   repeat with tIndex = 1 to the number of elements of tProject["stackfiles"]
      EnsureFolder item 1 to -2 of tProject["exported stackfiles"][tIndex]
      ExportStackFile tProject["imported stackfiles"][tIndex], tProject["exported stackfiles"][tIndex]
   end repeat
end ExportProject

command ImportProject pFilePath
   put ResolveProjectFile(pFilePath) into tProject
   set the itemDel to slash
   repeat with tIndex = the number of elements of tProject["stackfiles"] down to 1
      EnsureFolder item 1 to -2 of tProject["imported stackfiles"][tIndex]
      ImportStackFile tProject["exported stackfiles"][tIndex], tProject["imported stackfiles"][tIndex]
   end repeat
end ImportProject

command EnsureFolder pFolder
   set the itemDel to slash
   repeat with tFolder = 2 to the number of items of pFolder
      if there is not a folder (item 1 to tFolder of pFolder) then
         create folder (item 1 to tFolder of pFolder)
      end if
   end repeat
end EnsureFolder

function ResolveProjectFile pFilePath
   local tProject,tProjectPath
   
   put JSONToArray(url ("binfile:"&pFilePath)) into tProject
   
   # get project file path for relative path resolution
   set the itemDelimiter to slash
   put item 1 to -2 of pFilePath into tProjectPath
   if char -1 of tProjectPath is not slash then
      put slash after tProjectPath
   end if
   
   put merge(tProject["build path"]) into tProject["build path"]
   
   # resolve relative path
   if there is not a folder tProject["build path"] then
      put tProjectPath before tProject["build path"]
   end if
   
   if char -1 of tProject["build path"] is not slash then
      put slash after tProject["build path"]
   end if
   
   repeat for each key tIndex in tProject["stackfiles"]
      put tProjectPath & tProject["stackfiles"][tIndex] & "." & kExtension into tProject["exported stackfiles"][tIndex]
      put tProject["build path"] & tProject["stackfiles"][tIndex] into tProject["imported stackfiles"][tIndex]
   end repeat
   
   return tProject
end ResolveProjectFile

# Export the stackfile. Creates a directory at the same path as the stackfile&.kExtension
command ExportStackFile pFilePath,pFolder
   local tFolder,tStacks,tSubstacks,tIndex,tOldDefaultFolder,tRepo
   start using stack "lcVCS"
   lock screen
   put the defaultFolder into tOldDefaultFolder
   if there is a stack pFilePath then
      -- mainstack
      lock messages
      if pFolder is empty then
         put pFilePath into tFolder
         put "."&kExtension after tFolder
      else
         if there is a folder pFolder then
            put pFolder into tFolder
         else -- relative path
            put pFilePath into tFolder
            set the itemDel to slash
            put pFolder into item -1 of tFolder
         end if
      end if
      if there is not a folder tFolder then
         create folder tFolder
      end if
      set the defaultFolder to tFolder
      get ExportStack(the mainstack of stack pFilePath,true)
      -- substacks
      if the substacks of stack pFilePath is not empty then
         set the defaultFolder to tFolder
         if there is not a folder "substacks" then
            create folder "substacks"
         end if
         set the defaultFolder to "substacks"
         repeat for each line tStack in the substacks of stack pFilePath
            put tStack into tObjects[ExportStack(tStack)]
         end repeat
         deleteObjectsFromFolder tObjects
      end if
   end if
   set the defaultFolder to tOldDefaultFolder
   stop using stack "lcVCS"
end ExportStackFile

# Import a stackfile from a folder
on ImportStackFile pFolder,pFilePath
   local tUUIDSearchDone = "false",tOldDefaultFolder
   start using stack "lcVCS"
   lock screen
   lock messages
   put the defaultFolder into tOldDefaultFolder
   delete variable sUUIDsToResolve
   delete variable sLayersToSet
   delete variable sStacksToReopen
   set the defaultFolder to pFolder
   ImportObject
   put the short name of sIDMap[the result] into tMainstack
   -- only load UUIDs from all mainstacks if necessary
   repeat for each key tObject in sUUIDsToResolve
      repeat for each key tProperty in sUUIDsToResolve[tObject] 
         repeat for each line tUUID in sUUIDsToResolve[tObject][tProperty]
            -- resolve UUID references (icons, patterns, behaviors)
            -- load UUIDs from all mainstacks only if required
            if not tUUIDSearchDone and there is not a sIDMap[tUUID] then
               put true into tUUIDSearchDone
               repeat for each line tMainstack in the mainstacks
                  repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
                     repeat with tCard = 1 to the number of cards of stack tStack
                        -- behavior buttons
                        repeat with tControl =1 to the number of buttons of card tCard of stack tStack
                           if the uVersion["UUID"] of btn tControl of card tCard of stack tStack <> "" then
                              put the long id of btn tControl of card tCard of stack tStack into sIDMap[UUIDForObject(the long id of btn tControl of card tCard of stack tStack)]
                           end if
                        end repeat
                        -- images
                        repeat with tControl =1 to the number of images of card tCard of stack tStack
                           if the uVersion["UUID"] of image tControl of card tCard of stack tStack <> "" then
                              put the long id of image tControl of card tCard of stack tStack into sIDMap[UUIDForObject(the long id of image tControl of card tCard of stack tStack)]
                           end if
                        end repeat
                     end repeat
                  end repeat
               end repeat
            end if
         end repeat
         if there is a stack sPlugins[tProperty]["stack"] then
            dispatch "lcVCSResolveUUIDs" to stack sPlugins[tProperty]["stack"] with tObject
         else if there is a sIDMap[tUUID] then
            switch 
               case tProperty is "behavior"
                  set the tProperty of tObject to sIDMap[tUUID]
                  break
               case tProperty is "defaultButton"
                  set the default of sIDMap[tUUID] to true
                  break
               default
                  set the tProperty of tObject to the short id of sIDMap[tUUID]
                  break
            end switch
         else
            if there is not a stack sPlugins[tProperty]["stack"] then
               try -- could be some object that wasn't in memory during the export so it's not a UUID
                  set the tProperty of tObject to tUUID
               end try
            end if
         end if
      end repeat
   end repeat
   SetLayers
   if pFilePath is empty then
      set the itemDel to "."
      if item -1 of pFolder = "vcs" then
         delete item -1 of pFolder
      end if
      set the fileName of stack tMainStack to pFolder
   else
      set the itemDel to slash
      if there is a folder (item 1 to -2 of pFilePath) then
         set the fileName of stack tMainStack to pFilePath
      else -- relative path
         if char -1 of pFolder is "/" then
            delete char -1 of pFolder
         end if
         set the fileName of stack tMainStack to pFolder&"/"&pFilePath
      end if
   end if
   --save stack tMainstack
    if sConflicts is an array then
      modeless "lcVCSConflicts"
   end if
   set the defaultFolder to tOldDefaultFolder
   stop using stack "lcVCS"
   unlock messages
   repeat for each key tStack in sStacksToReopen
      set the topLeft of stack tStack to sStacksToReopen[tStack]
      go stack tStack
   end repeat
   if tMainStack = ("lcVCS"&kTempNameSuffix) then
      send "PostImportStack" to stack tMainStack in 0 milliseconds
   end if
end ImportStackFile

# Set the layers of controls
command SetLayers pDontClose
   local tLayers,tCardUUID,tObject,tCards
   -- interleave conflicted card layers
   repeat for each key tStackUUID in sLayersToSet["cardlayers"]
      repeat for each key tCardUUID in sLayersToSet["cardlayers"][tStackUUID]
         put tCardUUID,sLayersToSet["cardlayers"][tStackUUID][tCardUUID] &cr after tCards
      end repeat
      sort tCards numeric by item 2 of each
      repeat for each line tCard in tCards
         put item 1 of tCard into tCardUUID
         if tCardUUID = "" then next repeat
         go sIDMap[tCardUUID]
         put the keys of sLayersToSet["objectlayers"][tCardUUID] into tLayers
         sort tLayers numeric
         repeat for each line tLayer in tLayers
            try
               -- interleave conflicted layers
               repeat for each line tObject in sLayersToSet["objectlayers"][tCardUUID][tLayer]
                  relayer tObject to front of owner
               end repeat
            end try
         end repeat
         set the layer of sIDMap[tCardUUID] to sLayersToSet["cardlayers"][tStackUUID][tCardUUID]
      end repeat
      if not pDontClose then close sIDMap[tStackUUID]
      delete variable tCards
   end repeat
end SetLayers

-- if the stack gets this message then it just 
-- imported a version of itself with a temp name
on PostImportStack
   -- delete stacks (remove stackfile from memory)
   put the short name of this stack into tStack
   put tStack into tStackName
   replace kTempNameSuffix with empty in tStackName
   if there is a stack tStackName then
      delete stack tStackName
   end if
   -- set names correctly
   set the name of stack tStack to tStackName
   put the substacks of stack tStackName into tSubstacks
   repeat for each line tStack in tSubstacks
      put tStack into tStackName
      replace kTempNameSuffix with empty in tStackName
      if there is a stack tStackName then
         delete stack tStackName
      end if
      set the name of stack tStack to tStackName
   end repeat
end PostImportStack


on ImportObject pStackUUID,pCardUUID,pParentUUID
   local tObject,tSetName,tType,tError,tConflict=false
   put url ("binfile:properties.json") into tObject
   try
      put JSONToArray(tObject) into tObject["A"]
   catch tError
      -- most likely there's conflict markers causing an issue or someone's bad manual edit...
      put ParseConflictedFile(tObject) into tObject
      try
         put JSONToArray(tObject["A"]) into tObject["A"]
         put JSONToArray(tObject["B"]) into tObject["B"]
         -- make sure it's a real difference in an element value not 
         -- just the two branches adding to the last item of the same JSON object (trailing comma issue)
         -- union will add elements from one object to another but won't mess with existing elements
         union tObject["A"] with tObject["B"]
         union tObject["B"] with tObject["A"]
         -- if the arrays are now the same then we know it was just a trailing comma issue
         if tObject["A"] is tObject["B"] then
            delete variable tObject["B"]
         end if
      catch tError
         answer "There was an error decoding properties file:"&cr&the defaultFolder&"/properties.json"&cr&tError
         exit to top
      end try
   end try
   put uniDecode(uniEncode(tObject["A"]["properties"]["name"],"UTF8"),"ANSI") into tObject["A"]["properties"]["name"]
   switch tObject["A"]["class"]
      case "com.runrev.engine.stack"
         -- support VCS on self
         if tObject["A"]["properties"]["name"] = "lcVCS" or \
               (pStackUUID is not empty and the short name of sIDMap[pStackUUID] = ("lcVCS"&kTempNameSuffix))  then
            create stack (tObject["A"]["properties"]["name"]&kTempNameSuffix)
         else
            if there is a stack tObject["A"]["properties"]["name"] then
               repeat for each line tStack in the mainstack of stack tObject["A"]["properties"]["name"]&cr & the substacks of stack the mainstack of stack tObject["A"]["properties"]["name"]
                  if tStack is among the lines of the openStacks then
                     put the topLeft of stack tStack into  sStacksToReopen[tStack]
                  end if
               end repeat
               delete stack tObject["A"]["properties"]["name"]
            end if
            create stack tObject["A"]["properties"]["name"]
         end if
         set the defaultStack to it
         set the loc of it to the screenLoc
         -- workaround for the fact that the first card is already created
         -- and we use this for a background creation card
         -- a new stack id is always 1002 so the id of 1000 will be safe
         set the id of card 1 of it to 1000
         if pStackUUID is not empty then
            set the mainstack of it to the short name of sIDMap[pStackUUID]
         end if
         put tObject["A"]["UUID"] into pStackUUID
         break
      case "com.runrev.engine.card"
         create card tObject["A"]["properties"]["name"]
         put tObject["A"]["UUID"] into pCardUUID
         break
      case "com.runrev.engine.image"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create image tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create image tObject["A"]["properties"]["name"]
         end if
         if there is a file ("image."&tObject["A"]["properties"]["paintCompression"]) then
            set the text of it to url ("binfile:image."&tObject["A"]["properties"]["paintCompression"])
         end if
         delete variable tObject["A"]["properties"]["paintCompression"]
         if tObject["A"]["properties"]["fileName"] is empty then
            delete variable tObject["A"]["properties"]["fileName"]
         end if
         break
      case "com.runrev.engine.button"
         ##! workaround bug http://quality.runrev.com/show_bug.cgi?id=10696
         set the style of the templateButton to tObject["A"]["properties"]["style"]
         delete variable tObject["A"]["properties"]["style"]
         if word 1 of sIDMap[pParentUUID] is "group" then
            create button tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create button tObject["A"]["properties"]["name"]
         end if
         reset the templateButton
         break
      case "com.runrev.engine.field"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create field tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create field tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.player"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create player tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create player tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.scrollbar"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create scrollbar tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create scrollbar tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.graphic"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create graphic tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create graphic tObject["A"]["properties"]["name"]
         end if
         break
      case "com.runrev.engine.group"
         if word 1 of sIDMap[pParentUUID] is "group" then
            create group tObject["A"]["properties"]["name"] in sIDMap[pParentUUID]
         else
            create group tObject["A"]["properties"]["name"]
         end if
         set the lockUpdates of it to true
         break
      default
         ##! TODO
         -- custom control so find appropriate template object
         -- copy it to the appropriate spot
         
         break
   end switch
   if tObject["A"]["class"] <> "com.runrev.engine.stack" then
      put the abbrev id of it &" of "& sIDMap[pStackUUID] into sIDMap[tObject["A"]["UUID"]]
   else
      put it into sIDMap[tObject["A"]["UUID"]]
   end if
   set the itemDel to ","
   SetObjectProperties tObject["A"],pCardUUID,true
   put uniDecode(uniEncode(url ("binfile:script.utf8"),"UTF8"),"ANSI") into tScript
   set the script of sIDMap[tObject["A"]["UUID"]] to tScript
   -- conflict resolution
   if the result contains "<<<<<<<" then
      -- script compilation error caused by conflict markers
      AddToConflicts sIDMap[tObject["A"]["UUID"]],"script"
      put true into tConflict
   end if
   if tObject["B"] is an array then
      AddToConflicts sIDMap[tObject["A"]["UUID"]],"properties",tObject
      put true into tConflict
   end if
   if not tConflict then
      resolveConflict sIDMap[tObject["A"]["UUID"]]
   end if
   put tObject["A"]["UUID"] into tVersion["UUID"]
   put the short id of sIDMap[tObject["A"]["UUID"]] into tVersion["ID"]
   set the customProperties["uVersion"] of sIDMap[tObject["A"]["UUID"]] to tVersion
   if tObject["A"]["class"] <> "com.runrev.engine.stack" then
      repeat for each line tUUID in the folders
         if char 1 of tUUID = "." then next repeat
         set the defaultFolder to tUUID
         ImportObject pStackUUID,pCardUUID,tObject["A"]["UUID"]
         set the defaultFolder to ".."
      end repeat
   else
      repeat for each item tType in "cards,sharedGroups,substacks"
         if there is a folder tType then
            set the defaultFolder to tType
            repeat for each line tUUID in the folders
               if tType = "sharedGroups" then
                  go ("cd 1 of "&sIDMap[pStackUUID])
               end if
               if char 1 of tUUID = "." then next repeat
               set the defaultFolder to tUUID
               if tType = "substacks" then
                  ImportObject pStackUUID
               else
                  ImportObject pStackUUID,pCardUUID
               end if
               set the defaultFolder to ".."
            end repeat
            set the defaultFolder to ".."
         end if
         switch tType
            case "cards"
               -- find card layer 1 and put it's UUID into 
               repeat with X=1 to the number of cards of sIDMap[pStackUUID]
                  put UUIDForObject(the long id of card X of sIDMap[pStackUUID]) into pCardUUID
                  if sLayersToSet["cardlayers"][pCardUUID] is 1 then exit repeat
               end repeat
               break
            case "sharedGroups"
               delete card 1
               close this stack
               break
         end switch
      end repeat
   end if
   if tObject["A"]["class"] is "com.runrev.engine.group" then
      set the lockUpdates of sIDMap[tObject["A"]["UUID"]] to false
   end if
   return pStackUUID
end ImportObject

command SetObjectProperties pProperties,pCardUUID,pDontSetNames
   local tOwner,tUUIDsToResolve,tCurrentProps
   if pDontSetNames then
      delete variable pProperties["properties"]["name"]
   end if
   # clean the properties array
   -- set id first so it's already set when working out the UUIDs to resolve
   try
      set the id of sIDMap[pProperties["UUID"]] to pProperties["properties"]["id"]
      put pProperties["properties"]["id"] into word 3 of sIDMap[pProperties["UUID"]]
   end try
   delete variable pProperties["properties"]["id"]
   put the properties of sIDMap[pProperties["UUID"]] into tCurrentProps
   repeat for each key tProperty in pProperties["properties"]
      switch
         case tProperty is "layer"
            if pProperties["class"] is "com.runrev.engine.card" then
               put pProperties["properties"][tProperty] into sLayersToSet["cardlayers"][UUIDForObject(the owner of sIDMap[pProperties["UUID"]])][pProperties["UUID"]]
            else
               if pProperties["properties"][tProperty] is an array then
                  put "" into tFirstCard["layer"]
                  -- it's a background that needs to be placed
                  repeat for each key tCardUUID in pProperties["properties"][tProperty]
                     put the abbrev id of sIDMap[pProperties["UUID"]]&" of "&sIDMap[tCardUUID] &cr after sLayersToSet["objectlayers"][tCardUUID][pProperties["properties"][tProperty][tCardUUID]]
                     try -- throws error if it's already on the card
                        place sIDMap[pProperties["UUID"]] onto sIDMap[tCardUUID]
                     end try
                  end repeat
               else
                  -- support calling this command independent of main import for conflict resolution
                  if pCardUUID is empty then
                     put the long owner of sIDMap[pProperties["UUID"]] into tOwner
                     repeat forever
                        if word 1 of tOwner is "card" then
                           put UUIDForObject(tOwner) into pCardUUID
                           exit repeat
                        end if
                        put the long owner of tOwner into tOwner
                     end repeat
                  end if
                  put sIDMap[pProperties["UUID"]] into sLayersToSet["objectlayers"][pCardUUID][pProperties["properties"][tProperty]]
               end if
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is among the items of kIconProps,kPatternProps
         case tProperty is "behavior"
         case tProperty is "defaultButton"
            -- store the value 
            if pProperties["properties"][tProperty] <> "" and pProperties["properties"][tProperty] <> 0 then
               put pProperties["properties"][tProperty] into sUUIDsToResolve[sIDMap[pProperties["UUID"]]][tProperty]
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case char 1 to 7 of tProperty is "unicode" -- "unicode"&tProperty
            -- utf8 encoded
            put uniEncode(pProperties["properties"][tProperty],"UTF8") into pProperties["properties"][tProperty]
            break
         case tProperty is among the items of "htmlText,hilite"
            if pProperties["properties"][tProperty] is an array then
               put the abbrev id of sIDMap[pProperties["UUID"]] into tAbbrevID
               repeat for each key tUUID in pProperties["properties"][tProperty]
                  put tAbbrevID&" of "&sIDMap[tUUID] into tControlRef
                  set the tProperty of tControlRef to pProperties["properties"][tProperty][tUUID]
               end repeat
            end if
         default
            if pProperties["properties"][tProperty] is tCurrentProps[tProperty] then
               delete variable pProperties["properties"][tProperty]
            end if
            break
      end switch
   end repeat
   
   # now we can set the cleaned properties array
   set the properties of sIDMap[pProperties["UUID"]] to pProperties["properties"]
   
   repeat for each key tCustomPropertySet in pProperties["customPropertySets"]
      if tCustomPropertySet is "customKeys" then
         set the customProperties[""] of sIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
      else
         set the customProperties[uniDecode(uniEncode(tCustomPropertySet,"UTF8"),"ANSI")] of sIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
      end if
      -- if there are UUIDs to resolve then add the set to sUUIDsToResolve so the plugin can do it
      if sPlugins[tCustomPropertySet]["resolve UUIDs"] then
         dispatch "lcVCSRegisterUUIDsToResolve" to stack sPlugins[tCustomPropertySet]["stack"] with sIDMap[pProperties["UUID"]],tUUIDsToResolve
         if tUUIDsToResolve is not empty then
            put tUUIDsToResolve into sUUIDsToResolve[sIDMap[pProperties["UUID"]]][tCustomPropertySet]
         end if
         delete variable tUUIDsToResolve
      end if
   end repeat
   
end SetObjectProperties

command AddToConflicts pObject,pType,pProperties
   put true into sConflicts[pObject][pType] 
   if pType = "properties" then
      put pProperties into sConflicts[pObject]["propertiesdata"]
   end if
end AddToConflicts

function getConflicts
   return sConflicts
end getConflicts

command resolveConflict pObject
   delete variable sConflicts[pObject]
end resolveConflict

function UUIDForObject pObject
   if not exists(pObject) then return empty
   put the customProperties["uVersion"] of pObject into tVersion
   if tVersion["UUID"] = "" or (word 1 of pObject is not "stack" and \
         the short id of pObject <> tVersion["ID"]) then
      put UUID() into tVersion["UUID"]
      put the short id of pObject into tVersion["ID"]
      set the customProperties["uVersion"] of pObject to tVersion
   end if
   return tVersion["UUID"]
end UUIDForObject

function ObjectForUUID pUUID
   if exists(sIDMap[pUUID]) then
      return the long id of sIDMap[pUUID]
   else
      return ""
   end if
end ObjectForUUID

function ExportStack pStack,tMainstack
   local tIndex,tIsOpen
   put pStack is among the lines of the openstacks into tIsOpen
   if not tIsOpen then
      go stack pStack
   end if
   set the defaultStack to pStack
   put UUIDForObject(the long id of stack pStack) into tUUID
   get ExportObject(the long id of stack pStack,,tMainstack)
   if not tIsOpen then
      close stack pStack
   end if
   return tUUID
end ExportStack

local sCheck

function ExportObjectProperties pObject,pShared,pMainstack
   local tImage,tObject,tGroupCardRef,tPaintCompression
   unlock messages
   dispatch "lcVCSExport" to pObject
   lock messages
   put UUIDForObject(pObject) into tObject["UUID"]
   if not pMainstack then
      if there is not a folder tObject["UUID"] then
         create folder tObject["UUID"]
      end if
      set the defaultFolder to tObject["UUID"]
   end if
   put pObject into sIDMap[tObject["UUID"]]
   -- properties
   put the properties of pObject into tObject["properties"]
   put uniDecode(uniEncode(tObject["properties"]["name"],"ANSI"),"UTF8") into tObject["properties"]["name"]
   -- unicode properties
   repeat for each item tProperty in kUnicodeProps
      if tObject["properties"][tProperty] is not empty then
         put uniDecode(tObject["properties"][tProperty],"UTF8") into tObject["properties"][tProperty]
      end if
   end repeat
   put word 1 of pObject is "button" and the short name of pObject is "tests" into sCheck
   if tObject["properties"]["behavior"] is not empty then
      put UUIDForObject(tObject["properties"]["behavior"]) into tObject["properties"]["behavior"]
   end if
   if the cIDEProperties["cCustomControlID"] of pObject <> "" then
      put the cIDEProperties["cCustomControlID"] of pObject into tObject["class"]
   else
      if word 1 of pObject is "bkgnd" then
         put "com.runrev.engine.group" into tObject["class"]
      else
         put "com.runrev.engine."&word 1 of pObject into tObject["class"]
      end if
   end if
   try
      put the script of pObject into tScript
      if tScript <> "" then
         put uniDecode(uniEncode(tScript,"ANSI"),"UTF8") into tScript
      end if
   catch e
      put "-- password protected scripts unspported" into tScript
   end try
   if word 1 of pObject is not "image" then
      repeat for each item tProperty in kPatternProps
         try
            put the tProperty of pObject into tID
            if tID <> "" and tID <> 0 then
               -- if unresolved the property will be cleared
               _internal resolve image id tID relative to pObject
               put it into tObject["properties"][tProperty]
               if there is a tObject["properties"][tProperty] then
                  put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
               end if
            end if
         end try
      end repeat
   end if
   switch word 1 of pObject
      case "stack"
         -- should be saved next to the folder
         delete variable tObject["properties"]["filename"]
         -- only want conflict on width and height difference not stack location
         delete variable tObject["properties"]["rect"]
         put the width of pObject into tObject["properties"]["width"]
         put the height of pObject into tObject["properties"]["height"]
         -- stack id is too likely to cause a conflict and will resolve itself anyway
         delete variable tObject["properties"]["id"]
         break
      case "image"
         if tObject["properties"]["filename"] is empty then
            put the paintCompression of pObject into tObject["properties"]["paintCompression"]
            if tObject["properties"]["paintCompression"] is "rle" then
               export pObject to file "image.png" as png with standard palette
               put "png" into tObject["properties"]["paintCompression"]
            else
               put tObject["properties"]["text"] into url ("binfile:image."&tObject["properties"]["paintCompression"])
            end if
            delete variable tObject["properties"]["text"]
         end if
         break
      case "card"
         if tObject["properties"]["defaultButton"] <> "" then
            put UUIDForObject(tObject["properties"]["defaultButton"]) into tObject["properties"]["defaultButton"]
         end if
         break
      case "group"
      case "bkgnd"
         -- no point exporting group rect if it's not locked
         if not the lockLoc of pObject then
            delete variable tObject["properties"]["rect"]
         end if
         if tObject["properties"]["sharedBehavior"] then
            -- get a layer for each card because they can ne different
            repeat for each line tCardID in the cardIDs of pObject
               put the long id of card id tCardID into tCardRef
               put the abbrev id of pObject&" of "&tCardRef into tGroupCardRef
               put the layer of tGroupCardRef into tObject["properties"]["layer"][UUIDForObject(tCardRef)]
            end repeat 
         end if
         break
      case "button"
         if not the sharedHilite of pObject and pShared then
            put word 3 of pObject into tID
            repeat for each line tCardID in the cardIDs of the defaultStack
               if there is a button id tID of card id tCardID of the defaultStack then
                  put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                  put the hilite of button id tID of card id tCardID of the defaultStack into tObject["properties"]["hilite"][tUUID]
               end if
            end repeat 
         end if 
         if "text" is among the lines of the keys of tObject["properties"] then
            put the text of pObject into tObject["properties"]["text"]
         end if
         repeat for each item tProperty in kIconProps
            try
               if tObject["properties"][tProperty] <> "" and tObject["properties"][tProperty] <> 0 then
                  _internal resolve image id tObject["properties"][tProperty] relative to pObject
                  put it into tObject["properties"][tProperty]
                  if tObject["properties"][tProperty] is not empty then
                     put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
                  end if
               end if
            end try
         end repeat
         break
      case "field"
         if not the sharedText of pObject and pShared then
            put word 3 of pObject into tID
            repeat for each line tCardID in the cardIDs of the defaultStack
               if there is a field id tID of card id tCardID of the defaultStack then
                  put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                  put the htmlText of field id tID of card id tCardID of the defaultStack into tObject["properties"]["htmlText"][tUUID]
               end if
            end repeat 
         end if
         break
   end switch
   if "label" is among the lines of the keys of tObject["properties"] then
      put the label of pObject into tObject["properties"]["label"]
   end if
   if "tooltip" is among the lines of the keys of tObject["properties"] then
      put the tooltip of pObject into tObject["properties"]["tooltip"]
   end if
   if "title" is among the lines of the keys of tObject["properties"] then
      put the title of pObject into tObject["properties"]["title"]
   end if
   -- custom properties
   if the customKeys of pObject is not empty or the customPropertySets of pObject is not empty then
      repeat for each line tCustomPropertySet in ""&cr&the customPropertySets of pObject
         put the customProperties[tCustomPropertySet] of pObject into tPropertySetA
         if tCustomPropertySet is "uVersion" then
            next repeat
         end if
         if tCustomPropertySet is "" then 
            put "customKeys" into tCustomPropertySet
         end if
         if there is a stack sPlugins[tCustomPropertySet]["stack"] then
            dispatch "lcVCSFilterExportedProps" to stack sPlugins[tCustomPropertySet]["stack"] with pObject,tPropertySetA
         end if
         if the number of elements in tPropertySetA > 0 then
            put tPropertySetA into tObject["customPropertySets"][uniDecode(uniEncode(tCustomPropertySet,"ANSI"),"UTF8")]
         end if
      end repeat
   end if
   if the number of elements of tObject["customPropertySets"] is 0 then
      delete variable tObject["customPropertySets"]
   end if
   if the number of elements of tObject["properties"] is 0 then
      delete variable tObject["properties"]
   end if
   put ArrayToJSON(tObject,,true) into tJSON
   put tJSON into url ("binfile:properties.json")
   if tScript is not empty then 
      put tScript into url ("binfile:script.utf8")
   else
      if there is a file "script.utf8" then
         delete file "script.utf8"
      end if
   end if
   return tObject["UUID"]
end ExportObjectProperties

function ExportObject pObject,pShared,pMainstack
   local tObjects
   -- properties of stack
   put ExportObjectProperties(pObject,pShared,pMainstack) into tUUID
   -- child objects
   put 1 into tIndex
   put the defaultFolder into tFolder
   switch word 1 of pObject
      case "stack"
         -- cards
         if there is not a folder "cards" then
            create folder "cards"
         end if
         set the defaultFolder to "cards"
         repeat for each line tID in the cardIDs of pObject
            put the long id of card id tID of pObject into tObjects[ExportObject(the long id of card id tID of pObject,,false)]
         end repeat
         deleteObjectsFromFolder tObjects
         delete variable tObjects
         -- shared groups
         if the sharedGroupIDs of pObject is not empty then
            set the defaultFolder to tFolder
            if there is not a folder "sharedGroups" then
               create folder "sharedGroups"
            end if
            set the defaultFolder to "sharedGroups"
            repeat for each line tID in the sharedGroupIDs of pObject
               put the long id of background id tID of pObject into tObjects[ExportObject(the long id of background id tID of pObject,true,false)]
            end repeat
            deleteObjectsFromFolder tObjects
            delete variable tObjects
         end if
         set the defaultFolder to tFolder
         break
      case "card"
      case "group"
      case "bkgnd"
         -- only if it's not a cusom control
         if the cIDEProperties["cCustomControlID"] of pObject = "" then
            if the number of controls of pObject is not 0 then
               repeat for each line tControlID in the childControlIDs of pObject
                  put the long id of control id tControlID of pObject into tControlRef
                  if not (word 1 of tControlRef is "group" and \
                        the sharedBehavior of tControlRef) then
                     put tControlRef into tObjects[ExportObject(tControlRef,pShared,false)]
                  end if
               end repeat
            end if
         end if
         deleteObjectsFromFolder tObjects
         delete variable tObjects
         break
   end switch
   if not pMainstack then
      set the defaultFolder to ".."
   end if
   return tUUID
end ExportObject

on deleteObjectsFromFolder tObjects
   -- delete folders from deleted stacks
   repeat for each line tFolder in the folders
      if tFolder is not ".." and tObjects[tFolder] = "" then
         revDeleteFolder tFolder
      end if
   end repeat
end deleteObjectsFromFolder

function q pParam
   return quote&pParam&quote
end q

# Check to see if the parameter is ASCII or not
# returns true if it is not ASCII and therefore needs encoding
function needsEncoding pData
   return pData is not empty AND (pData is not an ascii string or pData contains null)
end needsEncoding

function ParseConflictedFile tFile
   local tState,tReturn
   -- extract both versions of the file
   -- assumes someone hasn't done something crazy like change the conflicted marker length!!!
   repeat for each line tLine in tFile
      switch char 1 to 7 of tLine
         case "<<<<<<<" -- A starts on next line
            put "A" into tState
            break
         case "|||||||" -- Original starts on next line
            put "O" into tState
         case "=======" -- B starts on next line
            put "B" into tState
            break
         case ">>>>>>>" -- conflict ends
            put "" into tState
            break
         default
            if tState is "" then
               put tLine&cr after tReturn["A"]
               put tLine&cr after tReturn["B"]
            else
               if tState is not "O" then
                  put tLine&cr after tReturn[tState]
               end if
            end if
            break
      end switch
   end repeat
   return tReturn
end ParseConflictedFile

function sharedObject pObject
   repeat while there is a pObject
      if word 1 of the owner of pObject is "card" then
         if word 1 of pObject is "group" and the sharedBehavior of pObject then
            return true
         else
            return false
         end if
      end if
      put the owner of pObject into pObject
   end repeat
end sharedObject

function pathForObject pObject
   local tPath
   put "/" into tPath
   repeat forever
      put "/"&UUIDForObject(pObject) before tPath
      switch
         case word 1 of pObject is "card"
            put "/cards" before tPath
            break
         case (word 1 of pObject is "group" and the sharedBehavior of pObject) or word 1 of pObject = "bkgnd"
            put "/sharedGroups" before tPath
            break
         case word 1 of pObject is "stack" and the number of words of pObject is 5 
            put "/substacks" before tPath
            break
      end switch
      put the long owner of pObject into pObject
      if the number of words of pObject is 2 then
         exit repeat
      end if
   end repeat
   return the effective filename of pObject&"."&kExtension&tPath 
end pathForObject

-- this makes sure the datagrid behaviors have the same UUID on everyone's version of the IDE
command SetDataGridUUIDs
   local tVersion
   put the customProperties["uDataGridBehaviors"] of this stack into tVersion
   repeat for each key tID in tVersion
      set the customProperties["uVersion"] of control id tID of stack "revDataGridLibrary" to tVersion[tID]
      put the long id of  control id tID of stack "revDataGridLibrary" into sIDMap[tVersion[tID]["UUID"]]
   end repeat
   save stack "revDataGridLibrary"
end SetDataGridUUIDs

-- load plugins
command LoadPlugins
   local tOldDefaultFolder,tPath
   delete variable sPlugins -- just incase someone is reloading and has removed a plugin
   put the defaultFolder into tOldDefaultFolder
   put the effective filename of this stack into tPath
   set the itemDel to "/"
   put "lcVCSPlugins" into item -1 of tPath
   set the defaultFolder to tPath
   repeat for each line tStack in the files
      -- each plugin is named with the custom property set name
      if there is a stack tStack then 
         put the uResolveUUIDs of stack tStack into sPlugins[the uCustomPropertySet of stack tStack]["resolve UUIDs"]
         put the short name of stack tStack into sPlugins[the uCustomPropertySet of stack tStack]["stack"]
      end if
   end repeat
   set the defaultFolder to tOldDefaultFolder
end LoadPlugins

-- pArray - array to be encoded
-- pForceRootType - can force the root to be an object if it looks like an array
-- pPretty - include whitespace
function ArrayToJSON pArray,pForceRootType,pPretty,pKey
   local tArray,tKeys
   repeat for each line tKey in the keys of pArray
      if pArray[tKey] is an array then
         put "}"&ArrayToJSON(pArray[tKey],pForceRootType,,tKey) into tArray[tKey]
      else if pKey is not "properties" and needsEncoding(pArray[tKey]) then
         put "base64Decode("&base64Encode(pArray[tKey])&")" into tArray[tKey]
      else 
         -- force all elements to be strings
         put "}}"&pArray[tKey] into tArray[tKey]
      end if
   end repeat
   return mergJSONEncode("tArray",pForceRootType,pPretty)
end ArrayToJSON

function JSONToArray pJSON
   local tArray,tKeys
   if pJSON = "" then return ""
   put mergJSONDecode(pJSON,"tArray") into tKeys
   repeat for each line tKey in the keys of tArray
      if tKey is among the lines of tKeys then
         put JSONToArray(tArray[tKey]) into tArray[tKey]
      else
         if char 1 to 13 of tArray[tKey] is "base64Decode(" then
            put base64Decode(char 14 to -2 of tArray[tKey]) into tArray[tKey]
         end if
      end if
   end repeat
   return tArray
end JSONToArray
