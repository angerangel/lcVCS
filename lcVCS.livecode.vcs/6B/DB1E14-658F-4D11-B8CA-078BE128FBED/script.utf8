local sTreeA
local sRootFolder

on preOpenCard
   set the hideConsoleWindows to true
   if the environment is "development" then
      
      SetDataGridUUIDs
      LoadPlugins
      accept datagram connections on port 10000 with message "NewMessage"
      insert the script of btn "lcVCS FrontScript" into front
      
      if "revMenubar" is in the executionContexts or there is a stack "lcVCSLoader" then
         send "DeleteLoader" to me in 0 milliseconds
         modeless "lcVCSProjects"
      else
         if GetPreference("User Extensions") is not revEnvironmentCustomizationPath() then
            SetPreference "User Extensions",revEnvironmentCustomizationPath()
         end if
         if GetPreference("DataGrid Library Path") is not the effective filename of stack "revDataGridLibrary" then
            SetPreference "DataGrid Library Path", the effective filename of stack "revDataGridLibrary"
         end if
         
         # asynchronously fetch current projects
         --send "FetchProject" to me in 20 milliseconds
      end if
      close this stack
   else
      local tOut,tStack
      
      # we do this so we can import and export lcVCS using the CLI
      repeat for each line tStack in the mainstack of this stack&cr&the substacks of this stack
         set the name of stack tStack to uuid()
      end repeat
      
      try
         LoadEnvironment
         put the result into tOut
         
         if tOut is empty then
            ParseArgs
            put the result into tOut
         end if
         
         if tOut contains "error:" then
            write tOut&cr to STDERR
            write GetHelp()&cr to STDOUT
            quit 1
         else
            write tOut&cr to STDOUT
            quit 0
         end if
      catch e
         write e &cr to STDERR
         quit 2
      end try
   end if
end preOpenCard

-- funky stuff to reload lcVCS after it imports itself
on DeleteLoader
   if there is a stack "lcVCSLoader" then
      delete stack "lcVCSLoader"
   end if
end DeleteLoader

on NewMessage pIP,pData
   replace numToChar(13) with numToChar(11) in pData
   switch line 1 of pData
      case "EditScript"
      case "Inspect"
         if there is a stack (line 3 of pData) then
            local tObject
            put line 2 of pData into tObject
            if word 1 of tObject is "stack" then
               select empty
               go tObject
            else
               -- find first parent of object that is a card and go the card
               -- the owner of a shared group should be the first card it's on
               go FindParent(tObject,"card")
               choose pointer tool
               try
                  select tObject
               end try
            end if
            if line 1 of pData is "EditScript" then
               edit the script of tObject
            else
               send "revBuildPropertyPalette" to stack "revTemplatePalette"
            end if
         end if
         break
      case "WillExportProject"
         break
      case "DidExportProject"
         break
      case "WillExportStackFile"
         break
      case "DidExportStackFile"
         break
      case "WillImportProject"
         put ResolveProjectFile(line 2 of pData) into tProject
         repeat for each line tIndex in tProject["imported stackFiles"]
            try
               delete stack tProject["imported stackFiles"][tIndex]
            end try
         end repeat
         break
      case "DidImportProject"
         break
   end switch
   close socket pIP
end NewMessage

--on FetchProject
--   put line 1 of the keys of sProjects into tIndex
--   put sProjects[tIndex] into tPath
--   set the itemDel to slash
--   delete item -1 of tPath
--   put the defaultFolder into tOldDefaultFolder
--   set the defaultFolder to tPath
--   put "git fetch --all" into tProcess
--   open process tProcess for read
--   set the defaultFolder to tOldDefaultFolder
--   repeat 
--      read from process tProcess until linefeed
--      wait 20 milliseconds with messages
--      replace numToChar(13) with empty in it
--      if it is empty or the result is "eof" then exit repeat
--   end repeat
--   close process tProcess
--   put shell("git tag") into tTags
--   put shell("git describe") into tCurrent
--   if not tCurrent contains "cannont describe" then
--      set the itemDel to "-"
--      if the number of items of tCurrent > 1 then
--         put item 1 to -3 of tCurrent into tCurrent
--      end if
--      put tCurrent into tNewTag
--      repeat for each line tTag in tTags
--         if NewerVersion(tTag,tNewTag) then
--            put tTag into tNewTag
--         end if
--      end repeat
--      if tNewTag is not tCurrent then
--         put shell(merge("git cat-file -p `git rev-parse [[ tNewTag ]]`")) into tMessage
--      end if
--   end if
--   delete variable sProjects[tIndex]
--   if the number of elements of sProjects > 0 then
--      send "FetchProject" to me in 20 milliseconds
--   end if
--end FetchProject

function NewerVersion pV1,pV2
   set the itemDel to "."
   repeat with tItem = 1 to 3
      if item tItem of pV1 > item tItem of pV2 then
         return true
      else if item tItem of pV1 < item tItem of pV2 then
         return false
      end if
   end repeat
   return false
end NewerVersion

function GetHelp
   return "lcVCS (c) 2013 M E R Goulding Software Development" & cr \
         & cr \
         & "Version " & the uVersionNumber of this stack & cr \
         & cr \
         & "Usage:" & cr \
         & "      lcvcs open -file <relative object file or reference path> [-repo <repo path>]"&cr \
         & "      lcvcs name -file <relative object file or reference path> [-repo <repo path>]"&cr \
         & "      lcvcs status [-repo <repo path>]"&cr \
         & "      lcvcs import [-file <relative project file path>] [-repo <repo path>]"&cr \
         & "      lcvcs export [-file <relative project file path> [-stackfile <full path to stackfile>]] [-repo <repo path>]"&cr \
         & "      lcvcs install [-repo <repo path>]"&cr \
         & "      lcvcs help"&cr \
         & cr \
         & "Documentation:"& cr \
         & "      Relative paths are relative to the git repo root. Specify the optional repo"&cr \
         & "      path if executing from outside a git repo."&cr \
         & cr \
         & "      open      If the LiveCode IDE is open this option will open the"&cr \
         & "                card the object is on, select the object and if the file"&cr \
         & "                was a script will edit the script otherwise open the"&cr \
         & "                inspector."&cr \
         & cr \
         & "      name      Writes the long name of the object to STDOUT."&cr \
         & cr \
         & "      import    Import a specific project using the -file option or"&cr \
         & "                all projects in the repo."&cr \
         & cr \
         & "      export    Export a specific project using the -file option or"&cr \
         & "                all projects in the repo. Use the -stackfile option with"&cr \
         & "                the -file option "&cr \
         & cr \
         & "      install   Install git hooks."&cr \
         & cr \
         & "      help      You're reading it."&cr \
         & cr \
         & "Note:"&cr \
         & "       lcvcs+ relies on the lcvcs+ plugin, lcvcs plugin and mergJSON"&cr \
         & "       external installed in your user extensions directory."
end GetHelp

on ParseArgs
   local tProjectA,tOut,tProjects,tProject,tItem,tCommand,tOptionA,tOption
   repeat with X = 1 to $#
      put value("$"&X) into item X of tParams
   end repeat
   
   repeat for each item tOption in "-repo,-file,-stackfile"
      put itemOffset(tOption,tParams) into tItem
      if tItem is 0 then
         if tOption is "-repo" then
            put line 1 of shell("git rev-parse --show-toplevel") into tOptionA[char 2 to -1 of tOption]
         end if
      else
         put item tItem+1 of tParams into tOptionA[char 2 to -1 of tOption]
      end if
   end repeat
   
   repeat for each item tCommand in "install,status,name,open,import,export,help"
      put itemOffset(tCommand,tParams) into tItem
      if tItem is 0 then
         put empty into tCommand
      else
         exit repeat
      end if
   end repeat
   
   set the itemDel to slash
   
   if there is a folder tOptionA["repo"] then
      if char -1 of tOptionA["repo"] is not slash then
         put slash after tOptionA["repo"]
      end if
      if there is not a folder tOptionA["repo"] &".git" then
         return "error: directory is not a git repo"&cr
      end if
   end if
   
   local tObject,tType
   
   switch tCommand
      case "install"
         # install git hooks
         repeat for each word tHook in "post-checkout post-rewrite post-merge"
            put format("#!/bin/bash\nset -x\n\nlcvcs import\n") into url ("binfile:"&tOptionA["repo"]&".git/hooks/"&tHook)
            get shell ("chmod 755 "&quote&tOptionA["repo"]&".git/hooks/"&tHook&quote)
         end repeat
         break
      case "status"
         set the folder to tOptionA["repo"]
         put shell("git status --porcelain --untracked-files=all") into tStatus
         # group into projects
         put ProjectFiles(tOptionA["repo"]) into tProjects
         
         set the itemDel to slash
         
         local tName,tResults
         
         repeat for each line tProject in tProjects
            put ResolveProjectFile(tProject) into tProjectA
            put "Project "&tProjectA["name"]&cr&cr after tOut
            local tProjectClean=true
            repeat for each key tIndex in tProjectA["exported stackFiles"]
               put tStatus into tFilteredStatus
               put tProjectA["exported stackFiles"][tIndex] into tStackFile
               replace tOptionA["repo"] with empty in tStackFile
               filter tFilteredStatus with "* "&tStackFile&"/*"
               if tFilteredStatus is not empty then
                  put false into tProjectClean
                  delete char -4 to -1 of tStackFile
                  put "StackFile: "&tStackFile&cr&cr after tOut
                  repeat for each line tObject in tFilteredStatus
                     
                     ParsePath tOptionA["repo"],char 4 to -1 of tObject
                     put the result into tName
                     
                     switch char 1 to 2 of tObject
                        case "DD"
                           if "    "&tName is not in tResults["Unmerged"]["deleted by both"] then
                              put "    "&tName & cr after tResults["Unmerged"]["deleted by both"]
                           end if
                           break
                        case "AU"
                           if "    "&tName is not in tResults["Unmerged"]["added by us"] then
                              put "    "&tName & cr after tResults["Unmerged"]["added by us"]
                           end if
                           break
                        case "UD"
                           if "    "&tName is not in tResults["Unmerged"]["deleted by them"] then
                              put "    "&tName & cr after tResults["Unmerged"]["deleted by them"]
                           end if
                           break
                        case "UA"
                           if "    "&tName is not in tResults["Unmerged"]["added by them"] then
                              put "    "&tName & cr after tResults["Unmerged"]["added by them"]
                           end if
                           break
                        case "DU"
                           if "    "&tName is not in tResults["Unmerged"]["deleted by us"] then
                              put "    "&tName & cr after tResults["Unmerged"]["deleted by us"]
                           end if
                           break
                        case "AA"
                           if "    "&tName is not in tResults["Unmerged"]["added by both"] then
                              put "    "&tName & cr after tResults["Unmerged"]["added by both"]
                           end if
                           break
                        case "UU"
                           if "    "&tName is not in tResults["Unmerged"]["modified by both"] then
                              put "    "&tName & cr after tResults["Unmerged"]["modified by both"]
                           end if
                           break
                        default
                           switch char 2 of tObject
                              case "?"
                                 if "    "&tName is not in tResults["Untracked"] then
                                    put "    "&tName & cr after tResults["Untracked"]
                                 end if
                                 break
                              case "M"
                                 if "    "&tName is not in tResults["Modified"] then
                                    put "    "&tName & cr after tResults["Modified"]
                                 end if
                                 break
                              case "A"
                                 if "    "&tName is not in tResults["Added"] then
                                    put "    "&tName & cr after tResults["Added"]
                                 end if
                                 break
                              case "D"
                                 if "    "&tName is not in tResults["Deleted"] then
                                    put "    "&tName & cr after tResults["Deleted"]
                                 end if
                                 break
                              case "C"
                                 if "    "&tName is not in tResults["Copied"] then
                                    put "    "&tName & cr after tResults["Copied"]
                                 end if
                                 break
                           end switch
                           break
                     end switch
                  end repeat
                  put the keys of tResults["Unmerged"] into tTypeList
                  sort tTypeList
                  local tKeys
                  repeat for each line tType in tTypeList
                     if tResults["Unmerged"][tType] is not empty then
                        put "Unmerged"&&tType&cr&tResults["Unmerged"][tType]&cr after tOut
                     end if
                  end repeat
                  
                  repeat for each word tType in "Modified Added Deleted Copied Untracked"
                     if tResults[tType] is not empty then
                        put tType & cr & tResults[tType] after tOut
                     end if
                  end repeat
                  
                  delete variable tResults
                  delete variable sTreeA
               end if
            end repeat
            if tProjectClean then
               put "Clean" & cr after tOut
            end if
         end repeat
         break
      case "name"
         # Long name option writes the long name of the object to STDOUT
         ParsePath tOptionA["repo"],tOptionA["file"]
         put the result into tOut
         break
      case "open"
         # Open option uses sockets to tell the plugin in the IDE select the object etc
         # Find lcVCSProjects.json files
         put ProjectFiles(tOptionA["repo"]) into tProjects
         
         ParsePath tOptionA["repo"],tOptionA["file"]
         put the result into tOut
         
         if "error:" is not in tOut then
            
            put tOut into tObject
            put "Opening "&tOut&" in LiveCode" into tOut
            
            # Find relevant project file
            local tFound = false
            repeat for each line tProject in tProjects
               put ResolveProjectFile(tProject) into tProjectA
               repeat for each key tIndex in tProjectA["exported stackFiles"]
                  if tProjectA["exported stackFiles"][tIndex] is sRootFolder then
                     put true into tFound
                     exit repeat
                  end if
               end repeat
               if tFound then 
                  exit repeat
               end if
            end repeat
            
            # Send message to IDE
            local tCmd
            put item -1 of pFile into tType
            set the itemDel to "."
            put item 1 of tType into tType
            if tType is "script" then
               put "EditScript" into tCmd
            else
               put "Inspect" into tCmd
            end if
            DispatchMessage tCmd&cr&tObject&cr&tProjectA["imported stackFiles"][tIndex]&cr
            
         end if
         break
      case "import"
         if tOptionA["file"] is empty then
            # Find lcVCSProjects.json files
            put ProjectFiles(tOptionA["repo"]) into tProjects
         else
            if tProjects is empty then
               if there is not a file tOptionA["file"] then
                  put tOptionA["repo"] & tOptionA["file"] into tProjects
               else
                  put tOptionA["file"] into tProjects
               end if
            end if
         end if
         repeat for each line tProject in tProjects
            DispatchMessage "WillImportProject"&cr&tProject&cr
            ImportProject tProject
            put "Project imported "&tProject&cr after tOut
            DispatchMessage "DidImportProject"&cr&tProject&cr
         end repeat
         break
      case "export"
         if tOptionA["file"] is empty then
            # Find lcVCSProjects.json files
            put ProjectFiles(tOptionA["repo"]) into tProjects
         else
            if tProjects is empty then
               if there is not a file tOptionA["file"] then
                  put tOptionA["repo"] & tOptionA["file"] into tProjects
               else
                  put tOptionA["file"] into tProjects
               end if
            end if
         end if
         repeat for each line tProject in tProjects
            if tOptionA["stackfile"] is empty then
               DispatchMessage "WillExportProject"&cr&tProject&cr
            else
               DispatchMessage "WillExportStackFile"&cr&tOptionA["stackfile"]&cr
            end if
            ExportProject tProject,tOptionA["stackfile"]
            if tOptionA["stackfile"] is empty then
               put "Project exported "&tProject&cr after tOut
               DispatchMessage "DidExportProject"&cr&tProject&cr
            else
               put "Stackfile exported "&tOptionA["stackfile"]&cr after tOut
               DispatchMessage "WillExportStackFile"&cr&tOptionA["stackfile"]&cr
            end if
         end repeat
         break
      case "help"
         put GetHelp() into tOut
         break
      default
         return "error: incorrect options"&cr&cr
         break
   end switch
   return tOut
end ParseArgs

command DispatchMessage pMessage
   open datagram socket to "127.0.0.1:10000"
   write pMessage to socket "127.0.0.1:10000"
   close socket "127.0.0.1:10000"
end DispatchMessage

function ProjectFiles pPath
   local tProjects,tOldFolder,tFiles,tFolder,tFolders
   
   put the folder into tOldFolder
   set the folder to pPath
   
   put the files into tFiles
   filter tFiles with "lcVCSProject.json"
   if tFiles is not empty then
      return pPath & tFiles
   end if
   
   put the folders into tFolders
   filter tFolders without ".*"
   filter tFolders without "*.vcs"
   
   repeat for each line tFolder in tFolders
      put ProjectFiles(pPath & tFolder & slash) & cr after tProjects
   end repeat
   filter tProjects without empty
   
   set the folder to tOldFolder
   
   return tProjects
end ProjectFiles

on ParsePath pRepo,pFile
   put pRepo & pFile into tPath
   set the itemDel to slash
   
   put item -3 of tPath&item -2 of tPath into tUUID
   put item 1 to -4 of tPath into tFolder
   if not IsUUID(tUUID) then
      return "error: not a LiveCode object"
   end if
   
   if sTreeA is not an array then
      CreateVCSTree tFolder
   end if
   -- find the uuid in the tree building the long name of the object
   
   if there is not a file tPath then
      -- get the content of the file to work out what it was
      replace pRepo with empty in tFolder
      put "properties.json" into item -1 of tPath
      put shell("git show HEAD^:"&tPath) into tContent
      
      try
         put JSONToArray(tContent) into tObject
         set the itemDel to "."
         if tObject["properties"]["name"] is empty then
            put "id "&tObject["properties"]["id"] into tName
         else
            put quote&tObject["properties"]["name"]&quote into tName
         end if
         -- deleted object so can only work out the abbrev name
         return item -1 of tObject["class"] && tName
      catch e
         return "error: file not found"
      end try
   else
      return UUIDToObjectReference(tUUID)
   end if
end ParsePath

on CreateVCSTree pFolder
   put the defaultFolder into tOldFolder
   put pFolder into sRootFolder
   put ParseTree(pFolder) into sTreeA
   set the defaultFolder to tOldFolder
end CreateVCSTree

function ParseTree pFolder
   local tArray,tOldFolder
   
   put the defaultFolder into tOldFolder
   set the defaultFolder to pFolder
   repeat for each item tFile in "cards,sharedGroups,substacks,layers,mainstack"
      if there is a file (tFile&".txt") then
         repeat for each line tUUID in url ("file:"&tFile&".txt")
            if tFile is among the items of "layers,mainstack" then
               put ParseTree(sRootFolder&"/"&char 1 to 2 of tUUID&"/"&char 3 to -1 of tUUID) into tArray[tUUID]
            else
               put ParseTree(sRootFolder&"/"&char 1 to 2 of tUUID&"/"&char 3 to -1 of tUUID) into tArray[tFile][tUUID]
            end if
         end repeat
      end if
   end repeat
   
   set the defaultFolder to tOldFolder
   return tArray
end ParseTree

function UUIDToObjectReference pUUID
   return FindObjectReference(pUUID,sTreeA)
end UUIDToObjectReference

function FindObjectReference pUUID,pArray
   local tReference,tStat = false
   if pUUID is among the lines of the keys of pArray then
      put JSONToArray(url ("binfile:"&sRootFolder&"/"&char 1 to 2 of pUUID&"/"&char 3 to -1 of pUUID&"/properties.json")) into tProps
      set the itemDel to "."
      put item -1 of tProps["class"] into tReference
      if tProps["properties"]["name"] is not empty then
         put " "& quote&tProps["properties"]["name"]&quote after tReference
      else
         put " id "& tProps["properties"]["id"] after tReference
      end if
   else
      repeat for each key tUUID in pArray
         put FindObjectReference(pUUID,pArray[tUUID]) into tReference
         if tReference is not empty then
            if "cards" is not among the lines of the keys of pArray then
               put JSONToArray(url ("binfile:"&sRootFolder&"/"&char 1 to 2 of tUUID&"/"&char 3 to -1 of tUUID&"/properties.json")) into tProps
               set the itemDel to "."
               put " of " & item -1 of tProps["class"] after tReference
               if tProps["properties"]["name"] is not empty then
                  put " "& quote&tProps["properties"]["name"]&quote after tReference
               else
                  put " id "& tProps["properties"]["id"] after tReference
               end if
            end if
            exit repeat
         end if
      end repeat
   end if
   return tReference
end FindObjectReference

function IsUUID pUUID
   return matchText(pUUID,"(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
end IsUUID

private command LoadEnvironment
   local tExternal,tExternalLibraryName
   
   # load stacks into memory
   if there is not a stack GetPreference("DataGrid Library Path") then
      return "error: could not load DataGrid Library"
   end if
   
   SetDataGridUUIDs
   
   # recursively parse user extensions
   LoadStackFilesRecursively GetPreference("User Extensions")
   
   # load mergJSON
   put GetPreference("User Extensions")&"/Externals/mergJSON." into tExternal
   
   switch the platform
      case "Linux"
         put "so" after tExternal
         break
      case "Win32"
         put "dll" after tExternal
         break
      case "MacOS"
         put "bundle" after tExternal
         break
   end switch
   
   if the platform is "MacOS" then
      if there is not a folder tExternal then
         return "error: could not load mergJSON"
      end if
   else
      if there is not a file tExternal then
         return "error: could not load mergJSON"
      end if
   end if
   
   set the externals of the templateStack to tExternal
   put uuid() into tExternalLibraryName
   create invisible stack tExternalLibraryName
   start using stack tExternalLibraryName
   
   insert the script of btn "lcVCS BackScript" into back
   
   LoadPlugins
   
end LoadEnvironment

private command LoadStackFilesRecursively pPath
   local tOldFolder,tFolder,tFile
   
   put the folder into tOldFolder
   
   if there is a folder pPath then
      
      set the folder to pPath
      
      # recurse over folders
      repeat for each line tFolder in the folders
         if char 1 of tFolder is not "." then
            LoadStackFilesRecursively pPath & slash & tFolder
         end if
      end repeat
      
      # load stackFiles into memory
      repeat for each line tFile in the files
         if char 1 of tFile is not "." and "lcVCS" is not in tFile then
            get there is a stack (pPath & slash & tFile)
         end if
      end repeat
      
   end if
   
   set the folder to tOldFolder
end LoadStackFilesRecursively


