
constant kUnicodeProps = "unicodeTitle,unicodeLabel,unicodeToolTip,unicodeText"
constant kIconProps = "icon,hiliteIcon,disabledIcon,visitedIcon,armedIcon,hoverIcon"
constant kPatternProps = "forePattern,focusPattern,backPattern,borderPattern,bottomPattern,hilitePattern,shadowPattern,topPattern"
constant kExtension = "vcs"
constant kPropsToDelete = "defaultButton,armed"

local sUUIDMap -- an array with UUIDs as keys and object references as values
local sUUIDsToResolve -- object references are resolved once the stackFile is fully imported
local sLayersToSet -- layers are set once a stack is fully imported
local sConflicts -- conflict markers are parsed and the plugin assists resolution
local sPropsToSet -- properties that need to be set right at the end eg cantModify of stack
local sStacksToDelete -- stacks to delete after the import
local sCurrentStackFilePath -- the path to the stackFile currently being imported
local sPlugins -- an array with loaded plugins for UUID resolution and unnecessary custom property filtering
local sTempNameSuffix -- a suffix (uuid) used when lcVCS is importing itself
local sStackPath -- the path to the stack being imported
local sMainstackPath -- the path to the mainstack being imported

command ExportProject pFilePath
   start using stack "lcVCS"
   delete variable sUUIDMap
   lock messages
   put ResolveProjectFile(pFilePath) into tProject
   set the itemDel to slash
   repeat with tIndex = 1 to the number of elements of tProject["stackFiles"]
      EnsureFolder tProject["exported stackfiles"][tIndex]
      ExportStackFile tProject["imported stackfiles"][tIndex], tProject["exported stackfiles"][tIndex]
   end repeat
   stop using stack "lcVCS"
end ExportProject

command ImportProject pFilePath
   local tCaseSensitve,tProject
   start using stack "lcVCS"
   lock messages
   delete variable sUUIDMap
   LoadDataGridUUIDs
   delete variable sConflicts
   delete variable sStacksToDelete
   put uuid() into sTempNameSuffix
   put ResolveProjectFile(pFilePath) into tProject
   set the itemDel to slash
   repeat with tIndex = 1 to the number of elements of tProject["stackFiles"]
      EnsureFolder item 1 to -2 of tProject["imported stackFiles"][tIndex]
      ImportStackFile tProject["exported stackFiles"][tIndex], tProject["imported stackFiles"][tIndex], tProject["name"] = "lcVCS"
   end repeat
   repeat for each key tStack in sStacksToDelete
      delete stack tStack
   end repeat
   unlock messages
   if tProject["name"] = "lcVCS" then
      send "PostImportStack sTempNameSuffix" to stack ("lcVCS"&sTempNameSuffix) in 0 milliseconds
   end if
   stop using stack "lcVCS"
end ImportProject

command EnsureFolder pFolder
   set the itemDel to slash
   repeat with tFolder = 1 to the number of items of pFolder
      if there is not a folder (item 1 to tFolder of pFolder) then
         create folder (item 1 to tFolder of pFolder)
      end if
   end repeat
end EnsureFolder

function ResolveProjectFile pFilePath
   local tProject,tProjectPath
   
   put JSONToArray(url ("binfile:"&pFilePath)) into tProject
   
   # get project file path for relative path resolution
   set the itemDelimiter to slash
   put item 1 to -2 of pFilePath into tProjectPath
   if char -1 of tProjectPath is not slash then
      put slash after tProjectPath
   end if
   
   put merge(tProject["build path"]) into tProject["build path"]
   
   # resolve relative path
   if there is not a folder tProject["build path"] then
      put tProjectPath before tProject["build path"]
   end if
   
   if char -1 of tProject["build path"] is not slash then
      put slash after tProject["build path"]
   end if
   
   repeat for each key tIndex in tProject["stackFiles"]
      put tProjectPath & tProject["stackFiles"][tIndex] & "." & kExtension into tProject["exported stackFiles"][tIndex]
      put tProject["build path"] & tProject["stackFiles"][tIndex] into tProject["imported stackFiles"][tIndex]
   end repeat
   
   return tProject
end ResolveProjectFile

# Export the stackfile. Creates a directory at the same path as the stackfile&.kExtension
command ExportStackFile pFilePath,pFolder
   local tFolder,tStacks,tSubstacks,tIndex,tOldDefaultFolder
   lock screen
   put the defaultFolder into tOldDefaultFolder
   if there is a stack pFilePath then
      -- mainstack
      if pFolder is empty then
         put pFilePath into tFolder
         put "."&kExtension after tFolder
      else
         if there is a folder pFolder then
            put pFolder into tFolder
         else -- relative path
            put pFilePath into tFolder
            set the itemDel to slash
            put pFolder into item -1 of tFolder
         end if
      end if
      revDeleteFolder tFolder
      create folder tFolder
      set the defaultFolder to tFolder
      put tFolder into sMainstackPath
      put empty into url ("file:"&UUIDForObject(the long id of stack the mainstack of stack pFilePath))
      ExportStack the mainstack of stack pFilePath
      save stack pFilePath
   end if
   set the defaultFolder to tOldDefaultFolder
end ExportStackFile

# Import a stackfile from a folder
on ImportStackFile pFolder,pFilePath,pIslcVCS
   local tUUIDSearchDone = "false",tOldDefaultFolder,tStackFileMainstack,tUUIDs
   --lock screen
   lock messages
   put pFilePath into sCurrentStackFilePath
   put the defaultFolder into tOldDefaultFolder
   delete variable sUUIDsToResolve
   delete variable sLayersToSet
   delete variable sPropsToSet
   set the defaultFolder to pFolder
   put pFolder into sMainstackPath
   put the files into tUUIDs
   filter tUUIDs without "*.*"
   set the defaultFolder to UUIDToObjectPath(line 1 of tUUIDs)
   ImportObject "","","",pIslcVCS
   put the short name of sUUIDMap[the result] into tStackFileMainstack
   -- only load UUIDs from all mainstacks if necessary
   repeat for each key tObject in sUUIDsToResolve
      repeat for each key tProperty in sUUIDsToResolve[tObject] 
         repeat for each line tUUID in sUUIDsToResolve[tObject][tProperty]
            -- resolve UUID references (icons, patterns, behaviors)
            -- load UUIDs from all mainstacks only if required
            if not tUUIDSearchDone and there is not a sUUIDMap[tUUID] then
               put "searching for: "&tStackFileMainstack&tab&tObject&tab&tProperty&tab&sUUIDMap[tUUID]&tab&tUUID&cr after msg
               put true into tUUIDSearchDone
               repeat for each line tMainstack in the mainstacks
                  repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
                     repeat with tCard = 1 to the number of cards of stack tStack
                        -- behavior buttons
                        repeat with tControl =1 to the number of buttons of card tCard of stack tStack
                           if the uVersion["UUID"] of btn tControl of card tCard of stack tStack <> "" then
                              put the long id of btn tControl of card tCard of stack tStack into sUUIDMap[UUIDForObject(the long id of btn tControl of card tCard of stack tStack)]
                           end if
                        end repeat
                        -- images
                        repeat with tControl =1 to the number of images of card tCard of stack tStack
                           if the uVersion["UUID"] of image tControl of card tCard of stack tStack <> "" then
                              put the long id of image tControl of card tCard of stack tStack into sUUIDMap[UUIDForObject(the long id of image tControl of card tCard of stack tStack)]
                           end if
                        end repeat
                     end repeat
                  end repeat
               end repeat
            end if
         end repeat
         if there is a stack sPlugins[tProperty]["stack"] then
            dispatch "lcVCSResolveUUIDs" to stack sPlugins[tProperty]["stack"] with tObject
         else if there is a sUUIDMap[tUUID] then
            switch 
               case tProperty is "behavior"
                  replace sTempNameSuffix with empty in sUUIDMap[tUUID]
                  set the tProperty of tObject to sUUIDMap[tUUID]
                  break
               default
                  set the tProperty of tObject to the short id of sUUIDMap[tUUID]
                  break
            end switch
         else
            if there is not a stack sPlugins[tProperty]["stack"] then
               try -- could be some object that wasn't in memory during the export so it's not a UUID
                  set the tProperty of tObject to tUUID
               end try
            end if
         end if
      end repeat
   end repeat
   
   SetLayers
   
   if pFilePath is empty then
      set the itemDel to "."
      if item -1 of pFolder = "vcs" then
         delete item -1 of pFolder
      end if
      set the fileName of stack tStackFileMainstack to pFolder
   else
      set the itemDel to slash
      if there is a folder (item 1 to -2 of pFilePath) then
         set the fileName of stack tStackFileMainstack to pFilePath
      else -- relative path
         if char -1 of pFolder is "/" then
            delete char -1 of pFolder
         end if
         set the fileName of stack tStackFileMainstack to pFolder&"/"&pFilePath
      end if
   end if
   
   -- set cant modify
   repeat for each key tProperty in sPropsToSet
      repeat for each key tObject in sPropsToSet[tProperty]
         set the tProperty of tObject to sPropsToSet[tProperty][tObject]
      end repeat
   end repeat
   save stack tStackFileMainstack
   if not pIslcVCS then
      put "" into sStacksToDelete[tStackFileMainstack]
   end if
   
   set the defaultFolder to tOldDefaultFolder
end ImportStackFile

# Set the layers of controls
command SetLayers
   local tLayers,tCardUUID,tObject,tCards,tSharedGroupUUID,tStackUUID
   repeat for each key tSharedGroupUUID in sLayersToSet["sharedobjectlayers"]
      put the keys of sLayersToSet["sharedobjectlayers"][tSharedGroupUUID] into tLayers
      sort tLayers numeric
      repeat for each line tLayer in tLayers
         try
            -- interleave conflicted layers
            repeat for each line tObject in sLayersToSet["sharedobjectlayers"][tSharedGroupUUID][tLayer]
               relayer tObject to front of owner
            end repeat
         end try
      end repeat
   end repeat
   repeat for each key tStackUUID in sLayersToSet["cardlayers"]
      -- interleave conflicted card layers
      repeat for each key tCardUUID in sLayersToSet["cardlayers"][tStackUUID]
         put tCardUUID,sLayersToSet["cardlayers"][tStackUUID][tCardUUID] &cr after tCards
      end repeat
      sort tCards numeric by item 2 of each
      repeat for each line tCard in tCards
         put item 1 of tCard into tCardUUID
         if tCardUUID = "" then next repeat
         put the keys of sLayersToSet["objectlayers"][tCardUUID] into tLayers
         sort tLayers numeric
         repeat for each line tLayer in tLayers
            try
               -- interleave conflicted layers
               repeat for each line tObject in sLayersToSet["objectlayers"][tCardUUID][tLayer]
                  relayer tObject to front of owner
               end repeat
            end try
         end repeat
         set the layer of sUUIDMap[tCardUUID] to sLayersToSet["cardlayers"][tStackUUID][tCardUUID]
      end repeat
      delete variable tCards
   end repeat
   repeat for each key tGroup in sLayersToSet["hilitedbutton"]
      set the hilitedButton of tGroup to sLayersToSet["hilitedbutton"][tGroup]
   end repeat
end SetLayers

-- if the stack gets this message then it just 
-- imported a version of itself with a temp name
on PostImportStack pTempNameSuffix
   local tMainstacks,tStack,tStackName
   put the mainstacks into tMainstacks
   filter tMainstacks with "*"&pTempNameSuffix
   repeat for each line tMainstack in tMainstacks
      repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
         -- delete stacks (remove stackfile from memory)
         put tStack into tStackName
         replace pTempNameSuffix with empty in tStackName
         if there is a stack tStackName then
            delete stack tStackName
         end if
         -- set names correctly
         set the name of stack tStack to tStackName
         save stack tStackName
      end repeat
   end repeat
   -- funky stuff in order to reload lcVCS in memory
   create invisible stack "lcVCSLoader"
   set the script of stack "lcVCSLoader" to \
         format("on ReloadlcVCS\ndelete stack \"lcVCS\"\ngo stack revEnvironmentUserPluginsPath()&\"/lcVCS.livecode\"\nend ReloadlcVCS")
   send "ReloadlcVCS" to stack "lcVCSLoader" in 0 milliseconds
end PostImportStack


on ImportObject pStackUUID,pCardUUID,pParentUUID,pIslcVCS
   local tObject,tSetName,tType,tError,tConflict=false,tHilitedButton,tResize,tUUIDS,tStackPath
   put url ("binfile:properties.json") into tObject
   if tObject is not empty then
      try
         put JSONToArray(tObject) into tObject["A"]
      catch tError
         -- most likely there's conflict markers causing an issue or someone's bad manual edit...
         put ParseConflictedFile(tObject) into tObject
         try
            put JSONToArray(tObject["A"]) into tObject["A"]
            put JSONToArray(tObject["B"]) into tObject["B"]
            #! reinstate when union recursively is released
            --         -- make sure it's a real difference in an element value not 
            --         -- just the two branches adding to the last item of the same JSON object (trailing comma issue)
            --         -- union will add elements from one object to another but won't mess with existing elements
            --         union tObject["A"] with tObject["B"] recursively
            --         union tObject["B"] with tObject["A"] recursively
            --         -- if the arrays are now the same then we know it was just a trailing comma issue
            --         if tObject["A"] is tObject["B"] then
            --            delete variable tObject["B"]
            --         end if
         catch tError
            answer "There was an error decoding properties file:"&cr&the defaultFolder&"/properties.json"&cr&tError
            exit to top
         end try
      end try
      if there is a file "userstate.json" then
         try
            #! modify when union recursively is released
            put JSONToArray(url ("userstate.json")) into tUserState
            repeat for each key tCustomPropertySet in tUserState
               union tObject["A"]["customPropertySets"][tCustomPropertySet] with tUserState[tCustomPropertySet] 
            end repeat
            if tObject["B"] is an array then
               repeat for each key tCustomPropertySet in tUserState
                  union tObject["B"]["customPropertySets"][tCustomPropertySet] with tUserState[tCustomPropertySet] 
               end repeat
            end if
         end try
      end if
      put uniDecode(uniEncode(tObject["A"]["properties"]["name"],"UTF8"),"ANSI") into tObject["A"]["properties"]["name"]
      switch tObject["A"]["class"]
         case "com.runrev.engine.stack"
            put the defaultFolder into sStackPath
            -- support VCS on self
            if pIslcVCS then
               create stack (tObject["A"]["properties"]["name"]&sTempNameSuffix)
            else
               if there is a stack tObject["A"]["properties"]["name"] then
                  delete stack tObject["A"]["properties"]["name"]
               end if
               create stack tObject["A"]["properties"]["name"]
            end if
            set the defaultStack to it
            set the loc of it to the screenLoc
            -- workaround for the fact that the first card is already created
            -- and we use this for a background creation card
            -- a new stack id is always 1002 so the id of 1000 will be safe
            set the id of card 1 of it to 1000
            if pStackUUID is not empty then
               set the mainstack of it to the short name of sUUIDMap[pStackUUID]
            end if
            put tObject["A"]["UUID"] into pStackUUID
            break
         case "com.runrev.engine.card"
            create card tObject["A"]["properties"]["name"]
            put tObject["A"]["UUID"] into pCardUUID
            break
         case "com.runrev.engine.image"
            if word 1 of sUUIDMap[pParentUUID] is "group" then
               create image tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
            else
               create image tObject["A"]["properties"]["name"]
            end if
            if there is a file ("image."&tObject["A"]["properties"]["paintCompression"]) then
               set the text of it to url ("binfile:image."&tObject["A"]["properties"]["paintCompression"])
            end if
            delete variable tObject["A"]["properties"]["paintCompression"]
            if tObject["A"]["properties"]["fileName"] is empty then
               delete variable tObject["A"]["properties"]["fileName"]
            end if
            break
         case "com.runrev.engine.button"
            if word 1 of sUUIDMap[pParentUUID] is "group" then
               create button tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
            else
               create button tObject["A"]["properties"]["name"]
            end if
            reset the templateButton
            break
         case "com.runrev.engine.field"
            if word 1 of sUUIDMap[pParentUUID] is "group" then
               create field tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
            else
               create field tObject["A"]["properties"]["name"]
            end if
            break
         case "com.runrev.engine.player"
            if word 1 of sUUIDMap[pParentUUID] is "group" then
               create player tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
            else
               create player tObject["A"]["properties"]["name"]
            end if
            break
         case "com.runrev.engine.scrollbar"
            if word 1 of sUUIDMap[pParentUUID] is "group" then
               create scrollbar tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
            else
               create scrollbar tObject["A"]["properties"]["name"]
            end if
            break
         case "com.runrev.engine.graphic"
            if word 1 of sUUIDMap[pParentUUID] is "group" then
               create graphic tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
            else
               create graphic tObject["A"]["properties"]["name"]
            end if
            break
         case "com.runrev.engine.group"
            if word 1 of sUUIDMap[pParentUUID] is "group" then
               create group tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
            else
               create group tObject["A"]["properties"]["name"]
            end if
            set the lockUpdates of it to true
            break
         default
            ##! TODO
            -- custom control so find appropriate template object
            -- copy it to the appropriate spot
            
            break
      end switch
      if tObject["A"]["class"] <> "com.runrev.engine.stack" then
         put the abbrev id of it &" of "& sUUIDMap[pStackUUID] into sUUIDMap[tObject["A"]["UUID"]]
      else
         put it into sUUIDMap[tObject["A"]["UUID"]]
      end if
      set the itemDel to comma
      SetObjectProperties tObject["A"],pCardUUID,true
      put uniDecode(uniEncode(url ("binfile:script.utf8"),"UTF8"),"ANSI") into tScript
      set the script of sUUIDMap[tObject["A"]["UUID"]] to tScript
      -- conflict resolution
      if the result contains "<<<<<<<" then
         -- script compilation error caused by conflict markers
         AddToConflicts sUUIDMap[tObject["A"]["UUID"]],"script"
         put true into tConflict
      end if
      if tObject["B"] is an array then
         AddToConflicts sUUIDMap[tObject["A"]["UUID"]],"properties",tObject
         put true into tConflict
      end if
      put tObject["A"]["UUID"] into tVersion["UUID"]
      put the short id of sUUIDMap[tObject["A"]["UUID"]] into tVersion["ID"]
      set the customProperties["uVersion"] of sUUIDMap[tObject["A"]["UUID"]] to tVersion
      if tObject["A"]["class"] <> "com.runrev.engine.stack" then
         put the files into tUUIDs
         filter tUUIDs without "*.*"
         repeat for each line tUUID in tUUIDs
            set the defaultFolder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
            ImportObject pStackUUID,pCardUUID,tObject["A"]["UUID"],pIslcVCS
         end repeat
      else
         put the defaultFolder into tOriginalDefaultFolder
         repeat for each item tType in "cards,sharedGroups,substacks"
            if there is a folder tType then
               set the defaultFolder to tType
               put the files into tUUIDs
               filter tUUIDs without "*.*"
               repeat for each line tUUID in tUUIDs
                  if tType = "sharedGroups" then
                     go ("cd 1 of "&sUUIDMap[pStackUUID])
                  end if
                  set the defaultFolder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
                  ImportObject pStackUUID,pCardUUID,,pIslcVCS
               end repeat
            end if
            switch tType
               case "cards"
                  -- find card layer 1 and put it's UUID into 
                  repeat with X=1 to the number of cards of sUUIDMap[pStackUUID]
                     put sUUIDMap[the long id of card X of sUUIDMap[pStackUUID]] into pCardUUID
                     if sLayersToSet["cardlayers"][pCardUUID] is 1 then exit repeat
                  end repeat
                  break
               case "sharedGroups"
                  delete card 1
                  close this stack
                  break
            end switch
            set the defaultFolder to tOriginalDefaultFolder
         end repeat
      end if
      if tObject["A"]["class"] is "com.runrev.engine.group" then
         set the lockUpdates of sUUIDMap[tObject["A"]["UUID"]] to false
      end if
   end if
   return pStackUUID
end ImportObject

command SetObjectProperties pProperties,pCardUUID,pDontSetNames
   local tOwner,tUUIDsToResolve,tCurrentProps
   set the caseSensitive to true
   if pDontSetNames then
      delete variable pProperties["properties"]["name"]
   end if
   # clean the properties array
   -- set id first so it's already set when working out the UUIDs to resolve
   try
      if pProperties["properties"]["id"] is not empty then
         set the id of sUUIDMap[pProperties["UUID"]] to pProperties["properties"]["id"]
         put pProperties["properties"]["id"] into word 3 of sUUIDMap[pProperties["UUID"]]
      end if
   catch e
      put the long name of control id pProperties["properties"]["id"]&cr& \
            the long name of sUUIDMap[pProperties["UUID"]]&cr after msg
   end try
   delete variable pProperties["properties"]["id"]
   put the properties of sUUIDMap[pProperties["UUID"]] into tCurrentProps
   repeat for each key tProperty in pProperties["properties"]
      switch
         case tProperty is "resizable"
            set the resizable of sUUIDMap[pProperties["UUID"]] to false
         case tProperty is "cantModify"
            put pProperties["properties"][tProperty] into sPropsToSet[tProperty][sUUIDMap[pProperties["UUID"]]]
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is "hilitedButton"
            if pProperties["properties"][tProperty] is an integer then
               put pProperties["properties"][tProperty] into sLayersToSet["hilitedbuttons"][sUUIDMap[pProperties["UUID"]]]
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is "layer"
            if pProperties["class"] is "com.runrev.engine.card" then
               put pProperties["properties"][tProperty] into sLayersToSet["cardlayers"][sUUIDMap[the owner of sUUIDMap[pProperties["UUID"]]]][pProperties["UUID"]]
            else
               if pProperties["properties"][tProperty] is an array then
                  put "" into tFirstCard["layer"]
                  -- it's a background that needs to be placed
                  repeat for each key tCardUUID in pProperties["properties"][tProperty]
                     put the abbrev id of sUUIDMap[pProperties["UUID"]]&" of "&sUUIDMap[tCardUUID] &cr after sLayersToSet["objectlayers"][tCardUUID][pProperties["properties"][tProperty][tCardUUID]]
                     try -- throws error if it's already on the card
                        place sUUIDMap[pProperties["UUID"]] onto sUUIDMap[tCardUUID]
                     end try
                  end repeat
               else
                  put FindParent(sUUIDMap[pProperties["UUID"]],"group",true) into tSharedGroup
                  if tSharedGroup is not empty then
                     put the abbrev id of tSharedGroup&" of "&the abbrev id of the defaultStack into tSharedGroup
                     put the abbrev id of sUUIDMap[pProperties["UUID"]] && "of" && the abbrev id of the defaultStack &cr after sLayersToSet["sharedobjectlayers"][sUUIDMap[tSharedGroup]][pProperties["properties"][tProperty]]
                  else
                     -- support calling this command independent of main import for conflict resolution
                     if pCardUUID is empty then
                        put UUIDForObject(FindParent(sUUIDMap[pProperties["UUID"]],"card")) into pCardUUID
                     end if
                     put sUUIDMap[pProperties["UUID"]]&cr after sLayersToSet["objectlayers"][pCardUUID][pProperties["properties"][tProperty]]
                  end if
               end if
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is among the items of kIconProps,kPatternProps
         case tProperty is "behavior"
            -- store the value 
            if pProperties["properties"][tProperty] <> "" and pProperties["properties"][tProperty] <> 0 then
               put pProperties["properties"][tProperty] into sUUIDsToResolve[sUUIDMap[pProperties["UUID"]]][tProperty]
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case char 1 to 7 of tProperty is "unicode" -- "unicode"&tProperty
            -- utf8 encoded
            put uniEncode(pProperties["properties"][tProperty],"UTF8") into pProperties["properties"][tProperty]
            break
         case tProperty is among the items of "htmlText,hilite"
            if pProperties["properties"][tProperty] is an array then
               put the abbrev id of sUUIDMap[pProperties["UUID"]] into tAbbrevID
               repeat for each key tUUID in pProperties["properties"][tProperty]
                  put tAbbrevID&" of "&sUUIDMap[tUUID] into tControlRef
                  set the tProperty of tControlRef to pProperties["properties"][tProperty][tUUID]
               end repeat
            end if
         case tProperty is "repeatCount" -- possible side effects of deleting
         case tProperty is "showBorder" -- side effects of deleting
            break
         default
            if pProperties["properties"][tProperty] is tCurrentProps[tProperty] then
               delete variable pProperties["properties"][tProperty]
            end if
            break
      end switch
   end repeat
   
   # now we can set the cleaned properties array
   set the properties of sUUIDMap[pProperties["UUID"]] to pProperties["properties"]
   
   repeat for each key tCustomPropertySet in pProperties["customPropertySets"]
      if tCustomPropertySet is "customKeys" then
         set the customProperties[""] of sUUIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
      else
         set the customProperties[uniDecode(uniEncode(tCustomPropertySet,"UTF8"),"ANSI")] of sUUIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
      end if
      -- if there are UUIDs to resolve then add the set to sUUIDsToResolve so the plugin can do it
      if sPlugins[tCustomPropertySet]["resolve UUIDs"] then
         dispatch "lcVCSRegisterUUIDsToResolve" to stack sPlugins[tCustomPropertySet]["stack"] with sUUIDMap[pProperties["UUID"]],tUUIDsToResolve
         if tUUIDsToResolve is not empty then
            put tUUIDsToResolve into sUUIDsToResolve[sUUIDMap[pProperties["UUID"]]][tCustomPropertySet]
         end if
         delete variable tUUIDsToResolve
      end if
   end repeat
   
end SetObjectProperties

command AddToConflicts pObject,pType,pProperties
   put true into sConflicts[sCurrentStackFilePath][pObject][pType] 
   if pType = "properties" then
      put pProperties into sConflicts[sCurrentStackFilePath][pObject]["propertiesdata"]
   end if
end AddToConflicts

function GetConflicts
   return sConflicts
end GetConflicts

function UUIDForObject pObject
   # ensure uniqueness of UUID in project
   if not exists(pObject) then return empty
   put the customProperties["uVersion"] of pObject into tVersion
   if tVersion["UUID"] = "" or \
         (word 1 of pObject is not "stack" and the short id of pObject <> tVersion["ID"]) or \
         (sUUIDMap[tVersion["UUID"]] is not empty and sUUIDMap[tVersion["UUID"]] is not the long id of pObject) then
      put UUID() into tVersion["UUID"]
      put the short id of pObject into tVersion["ID"]
      set the customProperties["uVersion"] of pObject to tVersion
      put the long id of pObject into sUUIDMap[tVersion["UUID"]]
   end if
   return tVersion["UUID"]
end UUIDForObject

function ObjectForUUID pUUID
   if exists(sUUIDMap[pUUID]) then
      get the long id of sUUIDMap[pUUID]
      replace sTempNameSuffix with empty in it
      return it
   else
      return ""
   end if
end ObjectForUUID

command ExportStack pStack
   local tIndex,tIsOpen
   set the defaultStack to pStack
   ExportObject the long id of stack pStack
end ExportStack

function ExportObjectProperties pObject,pShared
   local tImage,tObject,tGroupCardRef,tPaintCompression,tPropertySetA,tUserStateSetA,tUserState,tSharedObject,tCardIDs,tObjectFirstCardRef,tOldDefaultFolder
   put the defaultFolder into tOldDefaultFolder
   unlock messages
   dispatch "lcVCSExport" to pObject
   lock messages
   set the caseSensitive to true
   put UUIDForObject(pObject) into tObject["UUID"]
   put sMainstackPath & slash & UUIDToObjectPath(tObject["UUID"]) into tObjectPath
   EnsureFolder tObjectPath
   set the defaultFolder to tObjectPath
   put pObject into sUUIDMap[tObject["UUID"]]
   -- properties
   put the properties of pObject into tObject["properties"]
   if "icon" is among the lines of the keys of tObject["properties"] and \
         tObject["properties"]["icon"] is empty then
      set the icon of pObject to 0
   end if
   -- delete some props
   repeat for each item tProperty in kPropsToDelete
      delete variable tObject["properties"][tProperty]
   end repeat
   put uniDecode(uniEncode(tObject["properties"]["name"],"ANSI"),"UTF8") into tObject["properties"]["name"]
   -- unicode properties
   repeat for each item tProperty in kUnicodeProps
      if tObject["properties"][tProperty] is not empty then
         put uniDecode(tObject["properties"][tProperty],"UTF8") into tObject["properties"][tProperty]
      end if
   end repeat
   if tObject["properties"]["behavior"] is not empty then
      put UUIDForObject(tObject["properties"]["behavior"]) into tObject["properties"]["behavior"]
   end if
   if the cIDEProperties["cCustomControlID"] of pObject <> "" then
      put the cIDEProperties["cCustomControlID"] of pObject into tObject["class"]
   else
      if word 1 of pObject is "bkgnd" then
         put "com.runrev.engine.group" into tObject["class"]
      else
         put "com.runrev.engine."&word 1 of pObject into tObject["class"]
      end if
   end if
   try
      put the script of pObject into tScript
      if tScript <> "" then
         put uniDecode(uniEncode(tScript,"ANSI"),"UTF8") into tScript
      end if
   catch e
      throw "password protected scripts unspported: "&the long name of pObject
   end try
   if word 1 of pObject is not "image" then
      repeat for each item tProperty in kPatternProps
         try
            put the tProperty of pObject into tID
            if tID <> "" and tID <> 0 then
               -- if unresolved the property will be cleared
               --_internal resolve image id tID relative to pObject
               --resolve image id tID relative to pObject
               #! Workaround using behavior heirarchy until resolve image syntax accepted
               get ResolveImage(tID,pObject)
               put it into tObject["properties"][tProperty]
               
               if there is a tObject["properties"][tProperty] then
                  put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
               end if
            end if
         catch e
            write e&cr to stdout
         end try
      end repeat
   end if
   switch word 1 of pObject
      case "stack"
         -- should be saved next to the folder
         delete variable tObject["properties"]["fileName"]
         -- only want conflict on width and height difference not stack location
         delete variable tObject["properties"]["rect"]
         put the width of pObject into tObject["properties"]["width"]
         put the height of pObject into tObject["properties"]["height"]
         -- stack id is too likely to cause a conflict and will resolve itself anyway
         delete variable tObject["properties"]["id"]
         break
      case "image"
         if tObject["properties"]["fileName"] is empty then
            put the paintCompression of pObject into tObject["properties"]["paintCompression"]
            if tObject["properties"]["paintCompression"] is "rle" then
               export pObject to file "image.png" as png with standard palette
               put "png" into tObject["properties"]["paintCompression"]
            else
               put tObject["properties"]["text"] into url ("binfile:image."&tObject["properties"]["paintCompression"])
            end if
            delete variable tObject["properties"]["text"]
         end if
         -- no point having merge conflicts on animated gif frames unless
         -- the it's specificially set to a specific frame
         if tObject["properties"]["repeatCount"] is not 0 then
            delete variable tObject["properties"]["currentFrame"]
         end if
         break
      case "group"
      case "bkgnd"
         -- no point exporting group rect if it's not locked
         if not the lockLoc of pObject then
            delete variable tObject["properties"]["rect"]
         end if
         if tObject["properties"]["sharedBehavior"] then
            -- get a layer for each card because they can be different
            repeat for each line tCardID in the cardIDs of pObject
               put the long id of card id tCardID into tCardRef
               put the abbrev id of pObject&" of "&tCardRef into tGroupCardRef
               put the layer of tGroupCardRef into tObject["properties"]["layer"][UUIDForObject(tCardRef)]
            end repeat 
         end if
         break
      case "button"
         if not the sharedHilite of pObject and pShared then
            put word 3 of pObject into tID
            repeat for each line tCardID in the cardIDs of the defaultStack
               if there is a button id tID of card id tCardID of the defaultStack then
                  put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                  put the hilite of button id tID of card id tCardID of the defaultStack into tObject["properties"]["hilite"][tUUID]
               end if
            end repeat 
         end if 
         if "text" is among the lines of the keys of tObject["properties"] then
            put the text of pObject into tObject["properties"]["text"]
         end if
         repeat for each item tProperty in kIconProps
            try
               if tObject["properties"][tProperty] <> "" and tObject["properties"][tProperty] <> 0 then
                  get ResolveImage(tObject["properties"][tProperty],pObject)
                  --_internal resolve image id tObject["properties"][tProperty] relative to pObject
                  put it into tObject["properties"][tProperty]
                  if tObject["properties"][tProperty] is not empty then
                     put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
                  else
                     put 0 into tObject["properties"][tProperty]
                  end if
               end if
            end try
         end repeat
         break
      case "field"
         if not the sharedText of pObject and pShared then
            put word 3 of pObject into tID
            repeat for each line tCardID in the cardIDs of the defaultStack
               if there is a field id tID of card id tCardID of the defaultStack then
                  put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                  put the htmlText of field id tID of card id tCardID of the defaultStack into tObject["properties"]["htmlText"][tUUID]
               end if
            end repeat 
         end if
         break
   end switch
   if not (word 1 of pObject is "group" and the sharedBehavior of pObject) and pShared then
      -- use layer from a consistent card
      put FindParent(pObject,"group",true) into tSharedObject
      put the cardIDs of tSharedObject into tCardIDs
      sort tCardIDs numeric
      put the abbrev id of pObject & " of card id " & line 1 of tCardIDs & " of " & the long name of the defaultStack into tObjectFirstCardRef
      put the layer of tObjectFirstCardRef into tObject["properties"]["layer"]
   end if
   -- custom properties
   if the customKeys of pObject is not empty or the customPropertySets of pObject is not empty then
      repeat for each line tCustomPropertySet in ""&cr&the customPropertySets of pObject
         put the customProperties[tCustomPropertySet] of pObject into tPropertySetA
         if tCustomPropertySet is "uVersion" then
            next repeat
         end if
         if tCustomPropertySet is "" then 
            put "customKeys" into tCustomPropertySet
         end if
         if there is a stack sPlugins[tCustomPropertySet]["stack"] then
            dispatch "lcVCSFilterExportedProps" to stack sPlugins[tCustomPropertySet]["stack"] with pObject,tPropertySetA,tWorkspaceSetA
         end if
         if the number of elements in tPropertySetA > 0 then
            put tPropertySetA into tObject["customPropertySets"][uniDecode(uniEncode(tCustomPropertySet,"ANSI"),"UTF8")]
         end if
         if the number of elements in tUserStateSetA > 0 then
            put tUserStateSetA into tUserState[uniDecode(uniEncode(tCustomPropertySet,"ANSI"),"UTF8")]
         end if
         delete variable tUserStateSetA
      end repeat
   end if
   if the number of elements of tObject["customPropertySets"] is 0 then
      delete variable tObject["customPropertySets"]
   end if
   if the number of elements of tObject["properties"] is 0 then
      delete variable tObject["properties"]
   end if
   put ArrayToJSON(tObject,,true) into tJSON
   put tJSON into url ("binfile:properties.json")
   if the number of elements of tUserState is not 0 then
      put ArrayToJSON(tUserState,,true) into tJSON
      put tJSON into url ("binfile:userstate.json")
   else
      if there is a file "userstate.json" then
         delete file "userstate.json"
      end if
   end if
   if tScript is not empty then 
      put tScript into url ("binfile:script.utf8")
   else
      if there is a file "script.utf8" then
         delete file "script.utf8"
      end if
   end if
   set the defaultFolder to tOldDefaultFolder
   return tObject["UUID"]
end ExportObjectProperties

command ExportObject pObject,pShared,pType
   local tObjects,tOldDefaultFolder
   put the defaultFolder into tOldDefaultFolder
   -- properties of stack
   put ExportObjectProperties(pObject,pShared) into tUUID
   -- child objects
   put 1 into tIndex
   switch word 1 of pObject
      case "stack"
         -- cards
         if there is not a folder (sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/cards") then
            create folder (sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/cards")
         end if
         repeat for each line tID in the cardIDs of pObject
            put empty into url ("file:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/cards/"&UUIDForObject(the long id of card id tID of pObject))
            ExportObject the long id of card id tID of pObject,,false
         end repeat
         -- shared groups
         if the sharedGroupIDs of pObject is not empty then
            if there is not a folder (sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/sharedGroups") then
               create folder (sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/sharedGroups")
            end if
            repeat for each line tID in the sharedGroupIDs of pObject
               put empty into url ("file:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/sharedGroups/"&UUIDForObject(the long id of background id tID of pObject))
               ExportObject the long id of background id tID of pObject,true,false
            end repeat
         end if
         -- substacks
         if the substacks of pObject is not empty then
            if there is not a folder (sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/substacks") then
               create folder (sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/substacks")
            end if
            repeat for each line tStack in the substacks of pObject
               put empty into url ("file:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/substacks/"&UUIDForObject(the long id of stack tStack))
               ExportStack tStack
            end repeat
         end if
         break
      case "card"
      case "group"
      case "bkgnd"
         -- only if it's not a cusom control
         if the cIDEProperties["cCustomControlID"] of pObject = "" then
            if the number of controls of pObject is not 0 then
               repeat for each line tControlID in the childControlIDs of pObject
                  put the long id of control id tControlID of pObject into tControlRef
                  if not (word 1 of tControlRef is "group" and \
                        the sharedBehavior of tControlRef) then
                     put empty into url ("file:" & sMainstackPath & slash & UUIDToObjectPath(tUUID) & slash & UUIDForObject(tControlRef))
                     ExportObject tControlRef,pShared,false
                  end if
               end repeat
            end if
         end if
         break
   end switch
end ExportObject

function q pParam
   return quote&pParam&quote
end q

# Check to see if the parameter is ASCII or not
# returns true if it is not ASCII and therefore needs encoding
function NeedsEncoding pData
   return pData is not empty AND (pData is not an ascii string or pData contains null)
end NeedsEncoding

function ParseConflictedFile tFile
   local tState,tReturn
   -- extract both versions of the file
   -- assumes someone hasn't done something crazy like change the conflicted marker length!!!
   repeat for each line tLine in tFile
      switch char 1 to 7 of tLine
         case "<<<<<<<" -- A starts on next line
            put "A" into tState
            break
         case "|||||||" -- Original starts on next line
            put "O" into tState
            break
         case "=======" -- B starts on next line
            put "B" into tState
            break
         case ">>>>>>>" -- conflict ends
            put "" into tState
            break
         default
            if tState is "" then
               put tLine&cr after tReturn["A"]
               put tLine&cr after tReturn["B"]
            else
               if tState is not "O" then
                  put tLine&cr after tReturn[tState]
               end if
            end if
            break
      end switch
   end repeat
   return tReturn
end ParseConflictedFile

function sharedObject pObject
   repeat while there is a pObject
      if word 1 of the owner of pObject is "card" then
         if word 1 of pObject is "group" and the sharedBehavior of pObject then
            return true
         else
            return false
         end if
      end if
      put the owner of pObject into pObject
   end repeat
end sharedObject

-- this makes sure the datagrid behaviors have the same UUID on everyone's version of the IDE
command SetDataGridUUIDs
   local tVersion
   put the customProperties["uDataGridBehaviors"] of me into tVersion
   repeat for each key tID in tVersion
      set the customProperties["uVersion"] of control id tID of stack "revDataGridLibrary" to tVersion[tID]
   end repeat
   save stack "revDataGridLibrary"
end SetDataGridUUIDs

-- this loads the datagrid's uuids so se don't go searching for them
command LoadDataGridUUIDs
   local tVersion
   put the customProperties["uDataGridBehaviors"] of me into tVersion
   repeat for each key tID in tVersion
      put the long id of control id tID of stack "revDataGridLibrary" into sUUIDMap[tVersion[tID]["UUID"]]
   end repeat
end LoadDataGridUUIDs

-- load plugins
command LoadPlugins
   local tOldDefaultFolder,tPath
   set the caseSensitive to true
   delete variable sPlugins -- just incase someone is reloading and has removed a plugin
   put the defaultFolder into tOldDefaultFolder
   put the effective filename of me into tPath
   set the itemDel to "/"
   put "lcVCSPlugins" into item -1 of tPath
   set the defaultFolder to tPath
   repeat for each line tStack in the files
      -- each plugin is named with the custom property set name
      if there is a stack tStack then 
         put the uResolveUUIDs of stack tStack into sPlugins[the uCustomPropertySet of stack tStack]["resolve UUIDs"]
         # case sensitive is on so use multiple lines to give the possible different case versions
         repeat for each line tCustomPropertySet in the uCustomPropertySet of stack tStack
            put the short name of stack tStack into sPlugins[tCustomPropertySet]["stack"]
         end repeat
      end if
   end repeat
   set the defaultFolder to tOldDefaultFolder
end LoadPlugins

-- pArray - array to be encoded
-- pForceRootType - can force the root to be an object if it looks like an array
-- pPretty - include whitespace
function ArrayToJSON pArray,pForceRootType,pPretty,pKey
   local tArray,tKeys
   set the caseSensitive to true
   repeat for each line tKey in the keys of pArray
      if pArray[tKey] is an array then
         put "}"&ArrayToJSON(pArray[tKey],pForceRootType,,tKey) into tArray[tKey]
      else if (pKey is not "properties" or tKey is "text") and needsEncoding(pArray[tKey]) then
         put "base64Decode("&base64Encode(pArray[tKey])&")" into tArray[tKey]
      else 
         -- force all elements to be strings
         put "}}"&pArray[tKey] into tArray[tKey]
      end if
   end repeat
   return mergJSONEncode("tArray",pForceRootType,pPretty)
end ArrayToJSON

function JSONToArray pJSON
   local tArray,tKeys
   if pJSON = "" then return ""
   set the caseSensitive to true
   put mergJSONDecode(pJSON,"tArray") into tKeys
   repeat for each line tKey in the keys of tArray
      if tKey is among the lines of tKeys then
         put JSONToArray(tArray[tKey]) into tArray[tKey]
      else
         if char 1 to 13 of tArray[tKey] is "base64Decode(" then
            put base64Decode(char 14 to -2 of tArray[tKey]) into tArray[tKey]
         end if
      end if
   end repeat
   return tArray
end JSONToArray

function FindParent pObject,pType,pShared
   local tStat = "true",tType
   
   put word 1 of pObject into tType
   if tType is "bkgnd" then
      put "group" into tType
   end if
   
   if pShared then
      if tType is "group" then
         put the sharedBehavior of pObject into tStat
      else if word 1 of pObject is "card" then
         return empty
      end if
   end if
   
   if tType is pType and tStat then
      return pObject
   else
      return FindParent(the long owner of pObject,pType,pShared)
   end if
end FindParent

function ProjectsFile
   return PreferencePath()&"/lcVCSProjects.json"
end ProjectsFile

function PreferencePath
   local tFolder
   
   if the platform is "Linux" then
      put "~/.lcVCS" into tFolder
   else
      put specialFolderPath("support")&"/lcVCS" into tFolder
   end if
   EnsureFolder tFolder
   
   return tFolder
end PreferencePath

// Return a path relative to the stack directory for an object
// Note stacks are treated differently and their data is in the stack directory
// c0/63d56b-c5b3-429e-af00-5a6f97d7464d
private function UUIDToObjectPath pUUID
   return char 1 to 2 of pUUID & slash & char 3 to -1 of pUUID
end UUIDToObjectPath

// Return a uuid for an object given the path relative to the stack directory
// Note stacks are treated differently and their data is in the stack directory
private function ObjectPathToUUID pObjectPath
   set the itemDelimiter to slash
   return item 1 of pObjectPath & item 2 of pObjectPath
end ObjectPathToUUID
