
constant kUnicodeProps = "unicodeTitle,unicodeLabel,unicodeToolTip,unicodeText"
constant kIconProps = "icon,hiliteIcon,disabledIcon,visitedIcon,armedIcon,hoverIcon"
constant kPatternProps = "forePattern,focusPattern,backPattern,borderPattern,bottomPattern,hilitePattern,shadowPattern,topPattern"
constant kExtension = "vcs"
constant kPropsToDelete = "defaultButton,armed,layer"
constant kPasswordProtectedStackPrefix = "34f35cd6-e2fb-4d4e-a93a-bcd12b40a930"

local sUUIDMap -- an array with UUIDs as keys and object references as values
local sUUIDsToResolve -- object references are resolved once the stackFile is fully imported
local sConflicts -- conflict markers are parsed and the plugin assists resolution
local sPropsToSet -- properties that need to be set right at the end eg cantModify of stack
local sStacksToDelete -- stacks to delete after the import
local sCurrentStackFilePath -- the path to the stackFile currently being imported
local sPlugins -- an array with loaded plugins for UUID resolution and unnecessary custom property filtering
local sTempNameSuffix -- a suffix (uuid) used when lcVCS is importing itself
local sStackPath -- the path to the stack being imported
local sMainstackPath -- the path to the mainstack being imported
local sSharedGroup -- keeps track of imported shared groups in a stack
local sUnsharedProps -- holds unshared data of shared objects until the group is placed

# Use the optional pStackFile parameter to export only one stackFile from
# a project. This should only be done if there is a plugin resetting
# the UUIDs of objects after a stack clone (and ideally after other object copies).
command ExportProject pFilePath,pStackFile
   local tProject
   start using me
   delete variable sUUIDMap
   lock messages
   put ResolveProjectFile(pFilePath) into tProject
   set the itemDel to slash
   repeat with tIndex = 1 to the number of elements of tProject["stackFiles"]
      # ensure all stacks are loaded into memory even if only exporting one file
      if there is a stack tProject["imported stackfiles"][tIndex] and \
            (pStackFile is empty or tProject["imported stackfiles"][tIndex] is pStackFile) then
         EnsureFolder tProject["exported stackfiles"][tIndex]
         ExportStackFile tProject["imported stackfiles"][tIndex], tProject["exported stackfiles"][tIndex]
      end if
   end repeat
   stop using me
end ExportProject

command ImportProject pFilePath
   local tCaseSensitve,tProject,tIsLcVCS
   
   start using me
   
   lock messages
   
   delete variable sUUIDMap
   LoadDataGridUUIDs
   delete variable sConflicts
   delete variable sStacksToDelete
   put uuid() into sTempNameSuffix
   
   put ResolveProjectFile(pFilePath) into tProject
   set the itemDel to slash
   put tProject["name"] = "lcVCS" and the environment is "development" into tIsLcVCS
   
   repeat with tIndex = 1 to the number of elements of tProject["stackFiles"]
      EnsureFolder item 1 to -2 of tProject["imported stackFiles"][tIndex]
      ImportStackFile tProject["exported stackFiles"][tIndex], tProject["imported stackFiles"][tIndex], tIsLcVCS
   end repeat
   
   repeat for each key tStack in sStacksToDelete
      set the cantDelete of stack tStack to false
      delete stack tStack
   end repeat
   
   unlock messages
   
   if tIsLcVCS then
      send "PostImportStack sTempNameSuffix" to stack ("lcVCS"&sTempNameSuffix) in 0 milliseconds
   end if
   
   stop using me
end ImportProject

function ResolveProjectFile pFilePath
   local tProject,tProjectPath
   
   put JSONToArray(url ("binfile:"&pFilePath)) into tProject
   
   # get project file path for relative path resolution
   set the itemDelimiter to slash
   put item 1 to -2 of pFilePath into tProjectPath
   if char -1 of tProjectPath is not slash then
      put slash after tProjectPath
   end if
   
   put merge(tProject["build path"]) into tProject["build path"]
   
   # resolve relative path
   if there is not a folder tProject["build path"] then
      put tProjectPath before tProject["build path"]
   end if
   
   if char -1 of tProject["build path"] is not slash then
      put slash after tProject["build path"]
   end if
   
   repeat for each key tIndex in tProject["stackFiles"]
      put tProjectPath & tProject["stackFiles"][tIndex] & "." & kExtension into tProject["exported stackFiles"][tIndex]
      put tProject["build path"] & tProject["stackFiles"][tIndex] into tProject["imported stackFiles"][tIndex]
   end repeat
   
   return tProject
end ResolveProjectFile

# Export the stackfile. Creates a directory at the same path as the stackfile&.kExtension
command ExportStackFile pFilePath,pFolder
   local tFolder,tStacks,tSubstacks,tIndex,tOriginalFolder
   lock screen
   put the folder into tOriginalFolder
   if there is a stack pFilePath then
      -- mainstack
      if pFolder is empty then
         put pFilePath into tFolder
         put "."&kExtension after tFolder
      else
         if there is a folder pFolder then
            put pFolder into tFolder
         else -- relative path
            put pFilePath into tFolder
            set the itemDel to slash
            put pFolder into item -1 of tFolder
         end if
      end if
      revDeleteFolder tFolder
      create folder tFolder
      set the folder to tFolder
      put tFolder into sMainstackPath
      put UUIDForObject(the long id of stack the mainstack of stack pFilePath) into url "file:mainstack"
      ExportStack the mainstack of stack pFilePath
      save stack pFilePath
   end if
   set the folder to tOriginalFolder
end ExportStackFile

# Import a stackfile from a folder
on ImportStackFile pFolder,pFilePath,pIslcVCS
   local tUUIDSearchDone = "false",tOriginalFolder,tStackFileMainstack,tUUIDs,tMainstackUUID
   --lock screen
   lock messages
   put pFilePath into sCurrentStackFilePath
   put the folder into tOriginalFolder
   delete variable sUUIDsToResolve
   delete variable sPropsToSet
   delete variable sUnsharedProps
   set the folder to pFolder
   put pFolder into sMainstackPath
   put url "file:mainstack" into tMainstackUUID
   set the folder to UUIDToObjectPath(tMainstackUUID)
   write "uuid:"&&tMainstackUUID&cr to stdout
   ImportObject "","","",pIslcVCS
   put the short name of sUUIDMap[tMainstackUUID] into tStackFileMainstack
   -- only load UUIDs from all mainstacks if necessary
   repeat for each key tObject in sUUIDsToResolve
      repeat for each key tProperty in sUUIDsToResolve[tObject] 
         repeat for each line tUUID in sUUIDsToResolve[tObject][tProperty]
            -- resolve UUID references (icons, patterns, behaviors)
            -- load UUIDs from all mainstacks only if required
            if not tUUIDSearchDone and there is not a sUUIDMap[tUUID] then
               put "searching for: "&tStackFileMainstack&tab&tObject&tab&tProperty&tab&sUUIDMap[tUUID]&tab&tUUID&cr after msg
               put true into tUUIDSearchDone
               repeat for each line tMainstack in the mainstacks
                  repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
                     repeat with tCard = 1 to the number of cards of stack tStack
                        -- behavior buttons
                        repeat with tControl =1 to the number of buttons of card tCard of stack tStack
                           if the uVersion["UUID"] of btn tControl of card tCard of stack tStack <> "" then
                              put the long id of btn tControl of card tCard of stack tStack into sUUIDMap[UUIDForObject(the long id of btn tControl of card tCard of stack tStack)]
                           end if
                        end repeat
                        -- images
                        repeat with tControl =1 to the number of images of card tCard of stack tStack
                           if the uVersion["UUID"] of image tControl of card tCard of stack tStack <> "" then
                              put the long id of image tControl of card tCard of stack tStack into sUUIDMap[UUIDForObject(the long id of image tControl of card tCard of stack tStack)]
                           end if
                        end repeat
                     end repeat
                  end repeat
               end repeat
            end if
         end repeat
         if there is a stack sPlugins[tProperty]["stack"] then
            dispatch "lcVCSResolveUUIDs" to stack sPlugins[tProperty]["stack"] with tObject
         else if there is a sUUIDMap[tUUID] then
            switch 
               case tProperty is "behavior"
                  replace sTempNameSuffix with empty in sUUIDMap[tUUID]
                  set the tProperty of tObject to sUUIDMap[tUUID]
                  break
               default
                  set the tProperty of tObject to the short id of sUUIDMap[tUUID]
                  break
            end switch
         else
            if there is not a stack sPlugins[tProperty]["stack"] then
               try -- could be some object that wasn't in memory during the export so it's not a UUID
                  set the tProperty of tObject to tUUID
               end try
            end if
         end if
      end repeat
   end repeat
   
   if pFilePath is empty then
      set the itemDel to "."
      if item -1 of pFolder = "vcs" then
         delete item -1 of pFolder
      end if
      set the fileName of stack tStackFileMainstack to pFolder
   else
      set the itemDel to slash
      if there is a folder (item 1 to -2 of pFilePath) then
         set the fileName of stack tStackFileMainstack to pFilePath
      else -- relative path
         if char -1 of pFolder is "/" then
            delete char -1 of pFolder
         end if
         set the fileName of stack tStackFileMainstack to pFolder&"/"&pFilePath
      end if
   end if
   
   -- set cant modify
   repeat for each key tProperty in sPropsToSet
      repeat for each key tObject in sPropsToSet[tProperty]
         set the tProperty of tObject to sPropsToSet[tProperty][tObject]
      end repeat
   end repeat
   save stack tStackFileMainstack
   if not pIslcVCS then
      put "" into sStacksToDelete[tStackFileMainstack]
   end if
   
   set the folder to tOriginalFolder
end ImportStackFile

-- if the stack gets this message then it just 
-- imported a version of itself with a temp name
on PostImportStack pTempNameSuffix
   local tMainstacks,tStack,tStackName
   put the mainstacks into tMainstacks
   filter tMainstacks with "*"&pTempNameSuffix
   repeat for each line tMainstack in tMainstacks
      repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
         -- delete stacks (remove stackfile from memory)
         put tStack into tStackName
         replace pTempNameSuffix with empty in tStackName
         if there is a stack tStackName then
            set the cantDelete of stack tStackName to false
            delete stack tStackName
         end if
         -- set names correctly
         set the name of stack tStack to tStackName
         save stack tStackName
      end repeat
   end repeat
   -- funky stuff in order to reload lcVCS in memory
   create invisible stack "lcVCSLoader"
   set the script of stack "lcVCSLoader" to \
         format("on ReloadlcVCS\ndelete stack \"lcVCS\"\ngo stack revEnvironmentUserPluginsPath()&\"/lcVCS.livecode\"\nend ReloadlcVCS")
   send "ReloadlcVCS" to stack "lcVCSLoader" in 0 milliseconds
end PostImportStack


on ImportObject pStackUUID,pCardUUID,pParentUUID,pIslcVCS
   local tObject,tSetName,tType,tError,tConflict="false",tHilitedButton,tResize,tUUIDS,tStackPath,tUserState,tScript,tVersion,tOriginalFolder
   if there is a stack "stack.binary" then
      # clean the name
      put the short name of stack "stack.binary" into tName
      replace kPasswordProtectedStackPrefix with empty in tName
      set the name of stack "stack.binary" to tName
      
      # set the mainstack of substacks
      if pStackUUID is not empty then
         set the mainstack of stack tName to the short name of sUUIDMap[pStackUUID]
      end if
      
      put CleanLayerFile(url "file:substacks") into tUUIDs
      
      put UUIDForObject(the long id of stack tName) into pStackUUID
      
      LoadUUIDs the long id of stack tName
      
      repeat for each line tUUID in tUUIDs
         if sUUIDMap[tUUID] is empty then
            set the folder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
            ImportObject pStackUUID
         end if
      end repeat
   else
      put url ("binfile:properties.json") into tObject
      if tObject is not empty then
         try
            put JSONToArray(tObject) into tObject["A"]
         catch tError
            -- most likely there's conflict markers causing an issue or someone's bad manual edit...
            put ParseConflictedFile(tObject) into tObject
            try
               put JSONToArray(tObject["A"]) into tObject["A"]
               put JSONToArray(tObject["B"]) into tObject["B"]
               #! reinstate when union recursively is released
               --         -- make sure it's a real difference in an element value not 
               --         -- just the two branches adding to the last item of the same JSON object (trailing comma issue)
               --         -- union will add elements from one object to another but won't mess with existing elements
               --         union tObject["A"] with tObject["B"] recursively
               --         union tObject["B"] with tObject["A"] recursively
               --         -- if the arrays are now the same then we know it was just a trailing comma issue
               --         if tObject["A"] is tObject["B"] then
               --            delete variable tObject["B"]
               --         end if
            catch tError
               answer "There was an error decoding properties file:"&cr&the folder&"/properties.json"&cr&tError
               exit to top
            end try
         end try
         if there is a file "userstate.json" then
            try
               #! modify when union recursively is released
               put JSONToArray(url ("userstate.json")) into tUserState
               repeat for each key tCustomPropertySet in tUserState
                  union tObject["A"]["customPropertySets"][tCustomPropertySet] with tUserState[tCustomPropertySet] 
               end repeat
               if tObject["B"] is an array then
                  repeat for each key tCustomPropertySet in tUserState
                     union tObject["B"]["customPropertySets"][tCustomPropertySet] with tUserState[tCustomPropertySet] 
                  end repeat
               end if
            end try
         end if
         put uniDecode(uniEncode(tObject["A"]["properties"]["name"],"UTF8"),"ANSI") into tObject["A"]["properties"]["name"]
         switch tObject["A"]["class"]
            case "com.runrev.engine.stack"
               put the folder into sStackPath
               -- support VCS on self
               if pIslcVCS then
                  create stack (tObject["A"]["properties"]["name"]&sTempNameSuffix)
               else
                  if there is a stack tObject["A"]["properties"]["name"] then
                     set the cantDelete of stack tObject["A"]["properties"]["name"] to false
                     delete stack tObject["A"]["properties"]["name"]
                  end if
                  create stack tObject["A"]["properties"]["name"]
               end if
               set the defaultStack to it
               set the loc of it to the screenLoc
               -- workaround for the fact that the first card is already created
               -- and we use this for a background creation card
               -- a new stack id is always 1002 so the id of 1000 will be safe
               set the id of card 1 of it to 1000
               if pStackUUID is not empty then
                  set the mainstack of it to the short name of sUUIDMap[pStackUUID]
               end if
               put tObject["A"]["UUID"] into pStackUUID
               break
            case "com.runrev.engine.card"
               create card tObject["A"]["properties"]["name"]
               put tObject["A"]["UUID"] into pCardUUID
               break
            case "com.runrev.engine.image"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create image tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create image tObject["A"]["properties"]["name"]
               end if
               if there is a file ("image."&tObject["A"]["properties"]["paintCompression"]) then
                  set the text of it to url ("binfile:image."&tObject["A"]["properties"]["paintCompression"])
               end if
               delete variable tObject["A"]["properties"]["paintCompression"]
               if tObject["A"]["properties"]["fileName"] is empty then
                  delete variable tObject["A"]["properties"]["fileName"]
               end if
               break
            case "com.runrev.engine.button"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create button tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create button tObject["A"]["properties"]["name"]
               end if
               reset the templateButton
               break
            case "com.runrev.engine.field"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create field tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create field tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.player"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create player tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create player tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.scrollbar"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create scrollbar tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create scrollbar tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.graphic"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create graphic tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create graphic tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.group"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create group tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create group tObject["A"]["properties"]["name"]
               end if
               set the lockUpdates of it to true
               break
            default
               ##! TODO
               -- custom control so find appropriate template object
               -- copy it to the appropriate spot
               
               break
         end switch
         if tObject["A"]["class"] <> "com.runrev.engine.stack" then
            put the abbrev id of it &" of "& sUUIDMap[pStackUUID] into sUUIDMap[tObject["A"]["UUID"]]
         else
            put it into sUUIDMap[tObject["A"]["UUID"]]
         end if
         set the itemDel to comma
         SetObjectProperties tObject["A"],pCardUUID,true
         put uniDecode(uniEncode(url ("binfile:script.utf8"),"UTF8"),"ANSI") into tScript
         set the script of sUUIDMap[tObject["A"]["UUID"]] to tScript
         -- conflict resolution
         if the result contains "<<<<<<<" then
            -- script compilation error caused by conflict markers
            AddToConflicts sUUIDMap[tObject["A"]["UUID"]],"script"
            put true into tConflict
         end if
         if tObject["B"] is an array then
            AddToConflicts sUUIDMap[tObject["A"]["UUID"]],"properties",tObject
            put true into tConflict
         end if
         
         # set uVersion custom property set
         put tObject["A"]["UUID"] into tVersion["UUID"]
         put the short id of sUUIDMap[tObject["A"]["UUID"]] into tVersion["ID"]
         set the customProperties["uVersion"] of sUUIDMap[tObject["A"]["UUID"]] to tVersion
         
         if tObject["A"]["class"] <> "com.runrev.engine.stack" then
            put CleanLayerFile(url "file:layers") into tUUIDs
            
            local tSharedGroupsOnCard
            repeat for each line tUUID in tUUIDs
               if sSharedGroup[tUUID] then
                  if not tSharedGroupsOnCard[tUUID] then
                     -- sharedGroups are already created and just need to be relayered to front
                     relayer sUUIDMap[tUUID] to front of owner
                     put true into tSharedGroupsOnCard[tUUID]
                  end if
               else
                  if sUUIDMap[tUUID] is empty then
                     set the folder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
                     ImportObject pStackUUID,pCardUUID,tObject["A"]["UUID"],pIslcVCS
                  end if
               end if
            end repeat
            
            if tObject["A"]["class"] is "com.runrev.engine.card" then
               -- remove unplaced groups
               repeat for each key tUUID in sSharedGroup
                  if not tSharedGroupsOnCard[tUUID] then
                     remove sUUIDMap[tUUID] from sUUIDMap[tObject["A"]["UUID"]]
                  end if
               end repeat
               
               # set unshared properties of shared object
               repeat for each key tUUID in sUnsharedProps[tObject["A"]["UUID"]]
                  local tControlRef -- reference to object on this card
                  put the abbrev id of sUUIDMap[tUUID] && "of" && sUUIDMap[tObject["A"]["UUID"]] into tControlRef
                  repeat for each key tProperty in sUnsharedProps[tObject["A"]["UUID"]][tUUID]
                     set the tProperty of tControlRef to sUnsharedProps[tObject["A"]["UUID"]][tUUID][tProperty]
                  end repeat
               end repeat
            end if
            
            if tObject["A"]["class"] is "com.runrev.engine.group" then
               set the lockUpdates of sUUIDMap[tObject["A"]["UUID"]] to false
            end if
            
         else
            # if the stack was password protected it may still have substacks
            put the folder into tOriginalFolder
            repeat for each item tType in "sharedGroups,cards,substacks"
               put CleanLayerFile(url ("file:"&tType)) into tUUIDs
               
               repeat for each line tUUID in tUUIDs
                  if sUUIDMap[tUUID] is empty then
                     set the folder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
                     ImportObject pStackUUID,pCardUUID,,pIslcVCS
                  end if
               end repeat
               
               switch tType
                  case "cards"
                     delete card 1
                     close this stack
                     break
               end switch
               
               set the folder to tOriginalFolder
            end repeat
         end if
      end if
   end if
   return pStackUUID
end ImportObject

command SetObjectProperties pProperties,pCardUUID,pDontSetNames
   local tOwner,tUUIDsToResolve,tCurrentProps,tFirstCard,tSharedGroup,tAbbrevID,tControlRef
   set the caseSensitive to true
   if pDontSetNames then
      delete variable pProperties["properties"]["name"]
   end if
   # clean the properties array
   -- set id first so it's already set when working out the UUIDs to resolve
   try
      if pProperties["properties"]["id"] is not empty then
         set the id of sUUIDMap[pProperties["UUID"]] to pProperties["properties"]["id"]
         put pProperties["properties"]["id"] into word 3 of sUUIDMap[pProperties["UUID"]]
      end if
   catch e
      put the long name of control id pProperties["properties"]["id"]&cr& \
            the long name of sUUIDMap[pProperties["UUID"]]&cr after msg
   end try
   delete variable pProperties["properties"]["id"]
   put the properties of sUUIDMap[pProperties["UUID"]] into tCurrentProps
   
   if pProperties["properties"]["sharedBehavior"] then
      put true into sSharedGroup[pProperties["UUID"]]
   end if
   
   repeat for each key tProperty in pProperties["properties"]
      switch
         case tProperty is "resizable"
            set the resizable of sUUIDMap[pProperties["UUID"]] to false
         case tProperty is "cantModify"
            put pProperties["properties"][tProperty] into sPropsToSet[tProperty][sUUIDMap[pProperties["UUID"]]]
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is "hilitedButton"
            if pProperties["properties"][tProperty] is an integer then
               put pProperties["properties"][tProperty] into sLayersToSet["hilitedbuttons"][sUUIDMap[pProperties["UUID"]]]
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is among the items of kIconProps,kPatternProps
         case tProperty is "behavior"
            -- store the value 
            if pProperties["properties"][tProperty] <> "" and pProperties["properties"][tProperty] <> 0 then
               put pProperties["properties"][tProperty] into sUUIDsToResolve[sUUIDMap[pProperties["UUID"]]][tProperty]
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case char 1 to 7 of tProperty is "unicode" -- "unicode"&tProperty
            -- utf8 encoded
            put uniEncode(pProperties["properties"][tProperty],"UTF8") into pProperties["properties"][tProperty]
            break
         case tProperty is among the items of "htmlText,hilite"
            if pProperties["properties"][tProperty] is an array then
               put the abbrev id of sUUIDMap[pProperties["UUID"]] into tAbbrevID
               repeat for each key tUUID in pProperties["properties"][tProperty]
                  put pProperties["properties"][tProperty][tUUID] into sUnsharedProps[tUUID][pProperties["UUID"]][tProperty]
               end repeat
            end if
         case tProperty is "repeatCount" -- possible side effects of deleting
         case tProperty is "showBorder" -- side effects of deleting
            break
         default
            if pProperties["properties"][tProperty] is tCurrentProps[tProperty] then
               delete variable pProperties["properties"][tProperty]
            end if
            break
      end switch
   end repeat
   
   # now we can set the cleaned properties array
   set the properties of sUUIDMap[pProperties["UUID"]] to pProperties["properties"]
   
   repeat for each key tCustomPropertySet in pProperties["customPropertySets"]
      if tCustomPropertySet is "customKeys" then
         set the customProperties[""] of sUUIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
      else
         set the customProperties[uniDecode(uniEncode(tCustomPropertySet,"UTF8"),"ANSI")] of sUUIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
      end if
      -- if there are UUIDs to resolve then add the set to sUUIDsToResolve so the plugin can do it
      if sPlugins[tCustomPropertySet]["resolve UUIDs"] then
         dispatch "lcVCSRegisterUUIDsToResolve" to stack sPlugins[tCustomPropertySet]["stack"] with sUUIDMap[pProperties["UUID"]],tUUIDsToResolve
         if tUUIDsToResolve is not empty then
            put tUUIDsToResolve into sUUIDsToResolve[sUUIDMap[pProperties["UUID"]]][tCustomPropertySet]
         end if
         delete variable tUUIDsToResolve
      end if
   end repeat
   
end SetObjectProperties

private command LoadUUIDs pObject
   put pObject into sUUIDMap[UUIDForObject(pObject)]
   
   local tID,tSharedGroups
   switch word 1 of pObject
      case "stack"
         repeat for each line tID in the cardIDs of pObject
            LoadUUIDs "card id "&tID&" of "&pObject
         end repeat
         repeat for each line tID in the sharedGroupIDs of pObject
            LoadUUIDs "bkgnd id "&tID&" of "&pObject
         end repeat
         break
      case "card"
         put the sharedGroupIDs of pObject into tSharedGroups
         split tSharedGroups by row as set
      case "group"
      case "bkgnd"
         repeat for each line tID in the childControlIDs of pObject
            if not tSharedGroups[tID] then
               LoadUUIDs the long id of ("control id "&tID&" of "&pObject)
            end if
         end repeat
         break
   end switch
end LoadUUIDs

command AddToConflicts pObject,pType,pProperties
   put true into sConflicts[sCurrentStackFilePath][pObject][pType] 
   if pType = "properties" then
      put pProperties into sConflicts[sCurrentStackFilePath][pObject]["propertiesdata"]
   end if
end AddToConflicts

function GetConflicts
   return sConflicts
end GetConflicts

function UUIDForObject pObject
   local tVersion
   # ensure uniqueness of UUID in project
   if not exists(pObject) then return empty
   put the customProperties["uVersion"] of pObject into tVersion
   if tVersion["UUID"] = "" or \
         (word 1 of pObject is not "stack" and the short id of pObject <> tVersion["ID"]) or \
         (sUUIDMap[tVersion["UUID"]] is not empty and \
         the long id of sUUIDMap[tVersion["UUID"]] is not the long id of pObject) then
      put UUID() into tVersion["UUID"]
      put the short id of pObject into tVersion["ID"]
      set the customProperties["uVersion"] of pObject to tVersion
      put the long id of pObject into sUUIDMap[tVersion["UUID"]]
   end if
   return tVersion["UUID"]
end UUIDForObject

function ObjectForUUID pUUID
   if exists(sUUIDMap[pUUID]) then
      get the long id of sUUIDMap[pUUID]
      replace sTempNameSuffix with empty in it
      return it
   else
      return ""
   end if
end ObjectForUUID

command ExportStack pStack
   local tIndex,tIsOpen,tObjectPath
   delete variable sSharedGroup
   set the defaultStack to pStack
   
   ExportObject the long id of stack pStack,,,the password of stack pStack
   
   # if the stack was password protected then none of it's objects are exported
   # but each object still gets sent lcVCSExport and UUIDs are created for each object
   if the password of stack pStack then
      clone stack pStack
      set the name of it to (kPasswordProtectedStackPrefix&pStack)
      put sMainstackPath & slash & UUIDToObjectPath(UUIDForObject(the long ID of stack pStack)) into tObjectPath
      EnsureFolder tObjectPath
      set the fileName of stack (kPasswordProtectedStackPrefix&pStack) to tObjectPath & slash & "stack.binary"
      save stack (kPasswordProtectedStackPrefix&pStack)
      set the cantDelete of stack (kPasswordProtectedStackPrefix&pStack) to false
      delete stack (kPasswordProtectedStackPrefix&pStack)
   end if
   
end ExportStack

function ExportObjectProperties pObject,pShared,pPassword
   local tImage,tObject,tGroupCardRef,tPaintCompression,tPropertySetA,tUserStateSetA,tUserState,tSharedObject,tCardIDs,tObjectFirstCardRef,tOriginalFolder,tObjectPath,tScript,tID,tCardRef
   put the folder into tOriginalFolder
   unlock messages
   dispatch "lcVCSExport" to pObject
   lock messages
   set the caseSensitive to true
   put UUIDForObject(pObject) into tObject["UUID"]
   
   if not pPassword then
      put sMainstackPath & slash & UUIDToObjectPath(tObject["UUID"]) into tObjectPath
      EnsureFolder tObjectPath
      
      set the folder to tObjectPath
      put pObject into sUUIDMap[tObject["UUID"]]
      
      -- properties
      put the properties of pObject into tObject["properties"]
      -- delete some props
      repeat for each item tProperty in kPropsToDelete
         delete variable tObject["properties"][tProperty]
      end repeat
      put uniDecode(uniEncode(tObject["properties"]["name"],"ANSI"),"UTF8") into tObject["properties"]["name"]
      -- unicode properties
      repeat for each item tProperty in kUnicodeProps
         if tObject["properties"][tProperty] is not empty then
            put uniDecode(tObject["properties"][tProperty],"UTF8") into tObject["properties"][tProperty]
         end if
      end repeat
      if tObject["properties"]["behavior"] is not empty then
         put UUIDForObject(tObject["properties"]["behavior"]) into tObject["properties"]["behavior"]
      end if
      if the cIDEProperties["cCustomControlID"] of pObject <> "" then
         put the cIDEProperties["cCustomControlID"] of pObject into tObject["class"]
      else
         if word 1 of pObject is "bkgnd" then
            put "com.runrev.engine.group" into tObject["class"]
         else
            put "com.runrev.engine."&word 1 of pObject into tObject["class"]
         end if
      end if
      
      # get the script and UTF8 encode it
      put the script of pObject into tScript
      if tScript <> "" then
         put uniDecode(uniEncode(tScript,"ANSI"),"UTF8") into tScript
      end if
      
      if word 1 of pObject is not "image" then
         repeat for each item tProperty in kPatternProps
            try
               put the tProperty of pObject into tID
               if tID <> "" and tID <> 0 then
                  -- if unresolved the property will be cleared
                  --_internal resolve image id tID relative to pObject
                  --resolve image id tID relative to pObject
                  #! Workaround using behavior heirarchy until resolve image syntax accepted
                  get ResolveImage(tID,pObject)
                  put it into tObject["properties"][tProperty]
                  
                  if there is a tObject["properties"][tProperty] then
                     put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
                  end if
               end if
            catch e
               write e to STDOUT
            end try
         end repeat
      end if
      switch word 1 of pObject
         case "stack"
            -- should be saved next to the folder
            delete variable tObject["properties"]["fileName"]
            -- only want conflict on width and height difference not stack location
            delete variable tObject["properties"]["rect"]
            put the width of pObject into tObject["properties"]["width"]
            put the height of pObject into tObject["properties"]["height"]
            -- stack id is too likely to cause a conflict and will resolve itself anyway
            delete variable tObject["properties"]["id"]
            break
         case "image"
            if tObject["properties"]["fileName"] is empty then
               put the paintCompression of pObject into tObject["properties"]["paintCompression"]
               if tObject["properties"]["paintCompression"] is "rle" then
                  export pObject to file "image.png" as png with standard palette
                  put "png" into tObject["properties"]["paintCompression"]
               else
                  put tObject["properties"]["text"] into url ("binfile:image."&tObject["properties"]["paintCompression"])
               end if
               delete variable tObject["properties"]["text"]
            end if
            -- no point having merge conflicts on animated gif frames unless
            -- the it's specificially set to a specific frame
            if tObject["properties"]["repeatCount"] is not 0 then
               delete variable tObject["properties"]["currentFrame"]
            end if
            break
         case "group"
         case "bkgnd"
            -- no point exporting group rect if it's not locked
            if not the lockLoc of pObject then
               delete variable tObject["properties"]["rect"]
            end if
            break
         case "button"
            if not the sharedHilite of pObject and pShared then
               put word 3 of pObject into tID
               local tUUID
               repeat for each line tCardID in the cardIDs of the defaultStack
                  if there is a button id tID of card id tCardID of the defaultStack then
                     put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                     put the hilite of button id tID of card id tCardID of the defaultStack into tObject["properties"]["hilite"][tUUID]
                  end if
               end repeat 
            end if 
            if "text" is among the lines of the keys of tObject["properties"] then
               put the text of pObject into tObject["properties"]["text"]
            end if
            repeat for each item tProperty in kIconProps
               try
                  if tObject["properties"][tProperty] <> "" and tObject["properties"][tProperty] <> 0 then
                     get ResolveImage(tObject["properties"][tProperty],pObject)
                     --_internal resolve image id tObject["properties"][tProperty] relative to pObject
                     --resolve image id tObject["properties"][tProperty] relative to pObject
                     put it into tObject["properties"][tProperty]
                     if tObject["properties"][tProperty] is not empty then
                        put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
                     else
                        put 0 into tObject["properties"][tProperty]
                     end if
                  end if
               end try
            end repeat
            break
         case "field"
            if not the sharedText of pObject and pShared then
               put word 3 of pObject into tID
               repeat for each line tCardID in the cardIDs of the defaultStack
                  if there is a field id tID of card id tCardID of the defaultStack then
                     put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                     put the htmlText of field id tID of card id tCardID of the defaultStack into tObject["properties"]["htmlText"][tUUID]
                  end if
               end repeat 
            end if
            break
      end switch
      -- custom properties
      if the customKeys of pObject is not empty or the customPropertySets of pObject is not empty then
         repeat for each line tCustomPropertySet in ""&cr&the customPropertySets of pObject
            put the customProperties[tCustomPropertySet] of pObject into tPropertySetA
            if tCustomPropertySet is "uVersion" then
               next repeat
            end if
            if tCustomPropertySet is "" then 
               put "customKeys" into tCustomPropertySet
            end if
            if there is a stack sPlugins[tCustomPropertySet]["stack"] then
               dispatch "lcVCSFilterExportedProps" to stack sPlugins[tCustomPropertySet]["stack"] with pObject,tPropertySetA,tUserStateSetA
            end if
            if the number of elements in tPropertySetA > 0 then
               put tPropertySetA into tObject["customPropertySets"][uniDecode(uniEncode(tCustomPropertySet,"ANSI"),"UTF8")]
            end if
            if the number of elements in tUserStateSetA > 0 then
               put tUserStateSetA into tUserState[uniDecode(uniEncode(tCustomPropertySet,"ANSI"),"UTF8")]
            end if
            delete variable tUserStateSetA
         end repeat
      end if
      if the number of elements of tObject["customPropertySets"] is 0 then
         delete variable tObject["customPropertySets"]
      end if
      local tJSON
      put ArrayToJSON(tObject,,true) into tJSON
      put tJSON into url ("binfile:properties.json")
      if the number of elements of tUserState is not 0 then
         put ArrayToJSON(tUserState,,true) into tJSON
         put tJSON into url ("binfile:userstate.json")
      else
         if there is a file "userstate.json" then
            delete file "userstate.json"
         end if
      end if
      if tScript is not empty then 
         put tScript into url ("binfile:script.utf8")
      else
         if there is a file "script.utf8" then
            delete file "script.utf8"
         end if
      end if
      set the folder to tOriginalFolder
   end if
   
   return tObject["UUID"]
end ExportObjectProperties

command ExportObject pObject,pShared,pType,pPassword
   local tObjects,tOriginalFolder
   put the folder into tOriginalFolder
   -- properties of stack
   
   local tUUID
   put ExportObjectProperties(pObject,pShared,pPassword) into tUUID
   
   -- child objects
   local tIndex="1"
   switch word 1 of pObject
      case "stack"
         -- cards
         local tCards
         repeat for each line tID in the cardIDs of pObject
            put UUIDForObject(the long id of card id tID of pObject)&cr after tCards
            ExportObject the long id of card id tID of pObject,,false
         end repeat
         if not pPassword then
            put tCards into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/cards")
         end if
         -- shared groups
         local tSharedGroups
         if the sharedGroupIDs of pObject is not empty then
            repeat for each line tID in the sharedGroupIDs of pObject
               put UUIDForObject(the long id of background id tID of pObject)&cr after tSharedGroups
               ExportObject the long id of background id tID of pObject,true,false
            end repeat
            if not pPassword then
               put tSharedGroups into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/sharedGroups")
            end if
         end if
         -- substacks
         local tSubstacks
         if the substacks of pObject is not empty then
            repeat for each line tStack in the substacks of pObject
               put UUIDForObject(the long id of stack tStack)&cr after tSubstacks
               ExportStack tStack
            end repeat
            put tSubstacks into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/substacks")
         end if
         break
      case "card"
      case "group"
      case "bkgnd"
         -- only if it's not a cusom control
         if the cIDEProperties["cCustomControlID"] of pObject = "" then
            local tControlRef
            local tLayers
            repeat for each line tControlID in the childControlIDs of pObject
               put the long id of control id tControlID of pObject into tControlRef
               -- layer of shared groups in the list too
               put UUIDForObject(tControlRef)&cr after tLayers
               if not (word 1 of tControlRef is "group" and \
                     the sharedBehavior of tControlRef) then
                  ExportObject tControlRef,pShared,false
               end if
            end repeat
            if tLayers is not empty and not pPassword then
               put tLayers into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/layers")
            end if
         end if
         break
   end switch
end ExportObject

function q pParam
   return quote&pParam&quote
end q

# Check to see if the parameter is ASCII or not
# returns true if it is not ASCII and therefore needs encoding
function NeedsEncoding pData
   return pData is not empty AND (pData is not an ascii string or pData contains null)
end NeedsEncoding

function ParseConflictedFile tFile
   local tState,tReturn
   -- extract both versions of the file
   -- assumes someone hasn't done something crazy like change the conflicted marker length!!!
   repeat for each line tLine in tFile
      switch char 1 to 7 of tLine
         case "<<<<<<<" -- A starts on next line
            put "A" into tState
            break
         case "|||||||" -- Original starts on next line
            put "O" into tState
            break
         case "=======" -- B starts on next line
            put "B" into tState
            break
         case ">>>>>>>" -- conflict ends
            put "" into tState
            break
         default
            if tState is "" then
               put tLine&cr after tReturn["A"]
               put tLine&cr after tReturn["B"]
            else
               if tState is not "O" then
                  put tLine&cr after tReturn[tState]
               end if
            end if
            break
      end switch
   end repeat
   return tReturn
end ParseConflictedFile

-- this makes sure the datagrid behaviors have the same UUID on everyone's version of the IDE
command SetDataGridUUIDs
   local tVersion
   put the customProperties["uDataGridBehaviors"] of stack "lcVCS" into tVersion
   repeat for each key tID in tVersion
      set the customProperties["uVersion"] of control id tID of stack "revDataGridLibrary" to tVersion[tID]
   end repeat
end SetDataGridUUIDs

-- this loads the datagrid's uuids so se don't go searching for them
command LoadDataGridUUIDs
   local tVersion
   put the customProperties["uDataGridBehaviors"] of me into tVersion
   repeat for each key tID in tVersion
      put the long id of control id tID of stack "revDataGridLibrary" into sUUIDMap[tVersion[tID]["UUID"]]
   end repeat
end LoadDataGridUUIDs

-- load plugins
command LoadPlugins
   local tOriginalFolder,tPath
   set the caseSensitive to true
   delete variable sPlugins -- just incase someone is reloading and has removed a plugin
   put the folder into tOriginalFolder
   
   put revEnvironmentUserPluginsPath()&"/lcVCSPlugins" into tPath
   set the folder to tPath
   
   repeat for each line tStack in the files
      -- each plugin is named with the custom property set name
      if there is a stack tStack then 
         put the uResolveUUIDs of stack tStack into sPlugins[the uCustomPropertySet of stack tStack]["resolve UUIDs"]
         # case sensitive is on so use multiple lines to give the possible different case versions
         repeat for each line tCustomPropertySet in the uCustomPropertySet of stack tStack
            put the short name of stack tStack into sPlugins[tCustomPropertySet]["stack"]
         end repeat
      end if
   end repeat
   
   set the folder to tOriginalFolder
end LoadPlugins

-- pArray - array to be encoded
-- pForceRootType - can force the root to be an object if it looks like an array
-- pPretty - include whitespace
function ArrayToJSON pArray,pForceRootType,pPretty,pKey
   local tArray,tKeys
   set the caseSensitive to true
   repeat for each line tKey in the keys of pArray
      if pArray[tKey] is an array then
         put "}"&ArrayToJSON(pArray[tKey],pForceRootType,,tKey) into tArray[tKey]
      else if (pKey is not "properties" or tKey is "text") and needsEncoding(pArray[tKey]) then
         put "base64Decode("&base64Encode(pArray[tKey])&")" into tArray[tKey]
      else 
         -- force all elements to be strings
         put "}}"&pArray[tKey] into tArray[tKey]
      end if
   end repeat
   return mergJSONEncode("tArray",pForceRootType,pPretty)
end ArrayToJSON

function JSONToArray pJSON
   local tArray,tKeys
   if pJSON = "" then return ""
   set the caseSensitive to true
   put mergJSONDecode(pJSON,"tArray") into tKeys
   repeat for each line tKey in the keys of tArray
      if tKey is among the lines of tKeys then
         put JSONToArray(tArray[tKey]) into tArray[tKey]
      else
         if char 1 to 13 of tArray[tKey] is "base64Decode(" then
            put base64Decode(char 14 to -2 of tArray[tKey]) into tArray[tKey]
         end if
      end if
   end repeat
   return tArray
end JSONToArray

function FindParent pObject,pType,pShared
   local tStat = "true",tType
   
   put word 1 of pObject into tType
   if tType is "bkgnd" then
      put "group" into tType
   end if
   
   if pShared then
      if tType is "group" then
         put the sharedBehavior of pObject into tStat
      else if word 1 of pObject is "card" then
         return empty
      end if
   end if
   
   if tType is pType and tStat then
      return pObject
   else
      return FindParent(the long owner of pObject,pType,pShared)
   end if
end FindParent



// Return a path relative to the stack directory for an object
// Note stacks are treated differently and their data is in the stack directory
// c0/63d56b-c5b3-429e-af00-5a6f97d7464d
private function UUIDToObjectPath pUUID
   return char 1 to 2 of pUUID & slash & char 3 to -1 of pUUID
end UUIDToObjectPath

// Return a uuid for an object given the path relative to the stack directory
// Note stacks are treated differently and their data is in the stack directory
private function ObjectPathToUUID pObjectPath
   set the itemDelimiter to slash
   return item 1 of pObjectPath & item 2 of pObjectPath
end ObjectPathToUUID

# Cleans conflict markers
#! Warning - only use on layer files
#! TODO Improve with regex that handles all conflict markers
private function CleanLayerFile pData
   if "<<<<<<<" is in pData then
      filter pData without "<<<<<<<*"
      filter pData without "|||||||*"
      filter pData without "=======*"
      filter pData without ">>>>>>>*"
   end if
   return pData
end CleanLayerFile

on libraryStack
   # for some reason the behavior heirarchy of functions with syntax for different platforms
   # fails in 6.5+ so this is the workaround... when 6.5 is stable then drop all this and
   # run with 6.5 as the min version
   if the target is not me then pass libraryStack
   set the itemDel to "."
   if item 1 to 2 of the version >= 6.5 then
      set the behavior of btn "Common" of me to the long id of btn "resolve image"
   else
      set the behavior of btn "Common" of me to the long id of btn "_internal resolve image"
   end if
end libraryStack
